var documenterSearchIndex = {"docs":
[{"location":"writers/#Saving-the-diagnostics","page":"Saving output","title":"Saving the diagnostics","text":"","category":"section"},{"location":"writers/","page":"Saving output","title":"Saving output","text":"Do not forget to close your writers to avoid file corruption!","category":"page"},{"location":"writers/#NetCDFWriter","page":"Saving output","title":"NetCDFWriter","text":"","category":"section"},{"location":"writers/","page":"Saving output","title":"Saving output","text":"ClimaDiagnostics.Writers.NetCDF\nClimaDiagnostics.Writers.write_field!\nBase.close","category":"page"},{"location":"writers/#DictWriter","page":"Saving output","title":"DictWriter","text":"","category":"section"},{"location":"writers/","page":"Saving output","title":"Saving output","text":"The DictWriter is a in-memory writer that is particularly useful for interactive work and debugging.","category":"page"},{"location":"writers/","page":"Saving output","title":"Saving output","text":"ClimaDiagnostics.Writers.DictWriter\nClimaDiagnostics.Writers.write_field!","category":"page"},{"location":"writers/#HDF5Writer","page":"Saving output","title":"HDF5Writer","text":"","category":"section"},{"location":"writers/","page":"Saving output","title":"Saving output","text":"The HDF5Writer in ClimaDiagnostics is currently the least developed one.","category":"page"},{"location":"writers/","page":"Saving output","title":"Saving output","text":"ClimaDiagnostics.Writers.NetCDF\nClimaDiagnostics.Writers.write_field!\nBase.close","category":"page"},{"location":"api/#Public-APIs","page":"APIs","title":"Public APIs","text":"","category":"section"},{"location":"api/#ClimaDiagnostics","page":"APIs","title":"ClimaDiagnostics","text":"","category":"section"},{"location":"api/","page":"APIs","title":"APIs","text":"ClimaDiagnostics.DiagnosticsHandler\nClimaDiagnostics.DiagnosticsCallback","category":"page"},{"location":"api/#ClimaDiagnostics.DiagnosticsHandler","page":"APIs","title":"ClimaDiagnostics.DiagnosticsHandler","text":"The DiagnosticsHandler initializes the diagnostics by calling the  compute! function.\n\nNote: initializing a DiagnosticsHandler can be expensive!\n\nKeyword arguments\n\ndt, if passed, is used for error checking, to ensure that the diagnostics defined as given a given period are integer multiples of the timestep.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaDiagnostics.DiagnosticsCallback","page":"APIs","title":"ClimaDiagnostics.DiagnosticsCallback","text":"DiagnosticsCallback(diagnostics_handler::DiagnosticsHandler)\n\nTranslate a DiagnosticsHandler into a SciML callback ready to be used.\n\n\n\n\n\n","category":"function"},{"location":"api/#Callbacks","page":"APIs","title":"Callbacks","text":"","category":"section"},{"location":"api/","page":"APIs","title":"APIs","text":"ClimaDiagnostics.Callbacks.Callback\nClimaDiagnostics.Callbacks.CallbackOrchestrator\nClimaDiagnostics.Callbacks.AbstractSchedule\nClimaDiagnostics.Callbacks.short_name\nClimaDiagnostics.Callbacks.long_name\nClimaDiagnostics.Callbacks.DivisorSchedule\nClimaDiagnostics.Callbacks.EveryStepSchedule\nClimaDiagnostics.Callbacks.EveryDtSchedule\n","category":"page"},{"location":"api/#ClimaDiagnostics.Callbacks.Callback","page":"APIs","title":"ClimaDiagnostics.Callbacks.Callback","text":"Callback\n\nA lightweight struct that contains two functions, callback_func, the function that has to be called, and schedule_func, a boolean function that determines if it is time to call func or not.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaDiagnostics.Callbacks.CallbackOrchestrator","page":"APIs","title":"ClimaDiagnostics.Callbacks.CallbackOrchestrator","text":"CallbackOrchestrator(callbacks)\n\nReturn a SciMLBase.Callback that executes the diagnostic callbacks specified by diagnostics_callbacks according to their schedules.\n\ncallbacks has to be a container of Callbacks.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaDiagnostics.Callbacks.AbstractSchedule","page":"APIs","title":"ClimaDiagnostics.Callbacks.AbstractSchedule","text":"AbstractSchedule\n\nAbstractSchedules are structs that behave like functions and are used for the purpose of defining a schedule to be used in Callback. They also may contain additional information.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaDiagnostics.Callbacks.short_name","page":"APIs","title":"ClimaDiagnostics.Callbacks.short_name","text":"short_name(schedule)\n\nShort of name of the given schedule. Typically used in names of files/datasets.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaDiagnostics.Callbacks.long_name","page":"APIs","title":"ClimaDiagnostics.Callbacks.long_name","text":"long_name(schedule)\n\nLong of name of the given schedule. Typically used in attributes.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaDiagnostics.Callbacks.DivisorSchedule","page":"APIs","title":"ClimaDiagnostics.Callbacks.DivisorSchedule","text":"DivisorSchedule\n\nTrue when the iteration number is evenly divisible by a given number.\n\nThis is roughly equivalent to: \"run this call back every N steps\", with the difference that no initial offset is possible.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaDiagnostics.Callbacks.EveryStepSchedule","page":"APIs","title":"ClimaDiagnostics.Callbacks.EveryStepSchedule","text":"EveryStepSchedule()\n\nReturn a schedule that executes at the end of every step.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaDiagnostics.Callbacks.EveryDtSchedule","page":"APIs","title":"ClimaDiagnostics.Callbacks.EveryDtSchedule","text":"EveryDtSchedule\n\nTrue every time the current time is larger than the previous time this schedule was true + Dt.\n\nNote, this function performs no checks on whether the step is aligned with dt or not.\n\n\n\n\n\n","category":"type"},{"location":"api/#DiagnosticVariables","page":"APIs","title":"DiagnosticVariables","text":"","category":"section"},{"location":"api/","page":"APIs","title":"APIs","text":"ClimaDiagnostics.DiagnosticVariables.DiagnosticVariable\nClimaDiagnostics.DiagnosticVariables.short_name\nClimaDiagnostics.DiagnosticVariables.long_name\nClimaDiagnostics.DiagnosticVariables.descriptive_short_name\nClimaDiagnostics.DiagnosticVariables.descriptive_long_name","category":"page"},{"location":"api/#ClimaDiagnostics.DiagnosticVariables.DiagnosticVariable","page":"APIs","title":"ClimaDiagnostics.DiagnosticVariables.DiagnosticVariable","text":"DiagnosticVariable\n\nA recipe to compute a diagnostic variable from the state, along with some useful metadata.\n\nThe primary use for DiagnosticVariables is to be embedded in a ScheduledDiagnostic to compute diagnostics while the simulation is running.\n\nThe metadata is used exclusively by the output_writer in the ScheduledDiagnostic. It is responsibility of the output_writer to follow the conventions about the meaning of the metadata and their use.\n\nIn ClimaAtmos, we roughly follow the naming conventions listed in this file: https://airtable.com/appYNLuWqAgzLbhSq/shrKcLEdssxb8Yvcp/tblL7dJkC3vl5zQLb\n\nKeyword arguments\n\ncompute!: Function that compute the diagnostic variable from the state. It has to take             two arguments: the integrator, and a pre-allocated area of memory where to             write the result of the computation. It the no pre-allocated area is             available, a new one will be allocated. To avoid extra allocations, this             function should perform the calculation in-place (i.e., using .=).\nshort_name: Name used to identify the variable in the output files and in the file               names. Short but descriptive. ClimaAtmos follows the CMIP conventions and               the diagnostics are identified by the short name.\nlong_name: Name used to describe the variable in the output files.\nstandard_name: Standard name, as in                  http://cfconventions.org/Data/cf-standard-names/71/build/cf-standard-name-table.html\nunits: Physical units of the variable.\ncomments: More verbose explanation of what the variable is, or comments related to how             it is defined or computed.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaDiagnostics.DiagnosticVariables.short_name","page":"APIs","title":"ClimaDiagnostics.DiagnosticVariables.short_name","text":"short_name(dv::DiagnosticVariable)\n\nReturn the short name associated to the given DiagnosticVariable.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaDiagnostics.DiagnosticVariables.descriptive_short_name","page":"APIs","title":"ClimaDiagnostics.DiagnosticVariables.descriptive_short_name","text":"descriptive_short_name(variable::DiagnosticVariable,\n                       output_schedule_func,\n                       reduction_time_func,\n                       pre_output_hook!)\n\nReturn a compact, unique-ish, identifier generated from the given information. This function is useful for filenames and error messages.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaDiagnostics.DiagnosticVariables.descriptive_long_name","page":"APIs","title":"ClimaDiagnostics.DiagnosticVariables.descriptive_long_name","text":"descriptive_long_name(variable::DiagnosticVariable,\n                      output_every,\n                      reduction_time_func,\n                      pre_output_hook!)\n\nReturn a verbose description of the given output variable.\n\nThis function is useful for attributes in output files.\n\n\n\n\n\n","category":"function"},{"location":"api/#ScheduledDiagnostics","page":"APIs","title":"ScheduledDiagnostics","text":"","category":"section"},{"location":"api/","page":"APIs","title":"APIs","text":"ClimaDiagnostics.ScheduledDiagnostics.ScheduledDiagnostic\nClimaDiagnostics.ScheduledDiagnostics.output_short_name\nClimaDiagnostics.ScheduledDiagnostics.output_long_name","category":"page"},{"location":"api/#ClimaDiagnostics.ScheduledDiagnostics.ScheduledDiagnostic","page":"APIs","title":"ClimaDiagnostics.ScheduledDiagnostics.ScheduledDiagnostic","text":"ScheduledDiagnostic\n\nConceptually, a ScheduledDiagnostics is a DiagnosticVariable we want to compute in a given simulation. For example, it could be the temperature averaged over a day. We can have multiple ScheduledDiagnostics for the same DiagnosticVariable (e.g., daily and monthly average temperatures).\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaDiagnostics.ScheduledDiagnostics.output_short_name","page":"APIs","title":"ClimaDiagnostics.ScheduledDiagnostics.output_short_name","text":"output_short_name(sd::ScheduledDiagnostic)\n\nReturn the short name to use for output of the ScheduledDiagnostic sd.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaDiagnostics.ScheduledDiagnostics.output_long_name","page":"APIs","title":"ClimaDiagnostics.ScheduledDiagnostics.output_long_name","text":"output_long_name(sd::ScheduledDiagnostic)\n\nReturn the long name to use for output of the ScheduledDiagnostic sd.\n\n\n\n\n\n","category":"function"},{"location":"api/#Writers","page":"APIs","title":"Writers","text":"","category":"section"},{"location":"api/","page":"APIs","title":"APIs","text":"ClimaDiagnostics.AbstractWriter\nClimaDiagnostics.Writers.DictWriter\nClimaDiagnostics.Writers.NetCDFWriter\nClimaDiagnostics.Writers.HDF5Writer\nClimaDiagnostics.Writers.write_field!\nBase.close","category":"page"},{"location":"api/#ClimaDiagnostics.AbstractWriter","page":"APIs","title":"ClimaDiagnostics.AbstractWriter","text":"AbstractWriter\n\nAn object that knows how to save some output.\n\nAbstractWriters have to provide one function, write_field!\n\nThe function has to have signature write_field!(writer::Writer, field, diagnostic, u, p, t)\n\nIt is up to the Writer to implement this.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaDiagnostics.Writers.DictWriter","page":"APIs","title":"ClimaDiagnostics.Writers.DictWriter","text":"The DictWriter is a writer that does not write to disk, but to memory (in a dictionary).\n\nThis is particularly useful for testing and debugging. This is not type stable (the underlying dictionary does not know in advance what types might be used).\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaDiagnostics.Writers.NetCDFWriter","page":"APIs","title":"ClimaDiagnostics.Writers.NetCDFWriter","text":"NetCDFWriter(cspace, output_dir)\n\nSave a ScheduledDiagnostic to a NetCDF file inside the output_dir of the simulation by performing a pointwise (non-conservative) remapping first.\n\nKeyword arguments\n\ncspace: Space where the Fields are defined.\noutput_dir: The base folder where the files should be saved.\nnum_points: How many points to use along the different dimensions to interpolate the               fields. This is a tuple of integers, typically having meaning Long-Lat-Z,               or X-Y-Z (the details depend on the configuration being simulated).\ndisable_vertical_interpolation: Do not interpolate on the z direction, instead evaluate                                   at on levels. When disableverticalinterpolation is true,                                   the num_points on the vertical direction is ignored.\ncompression_level: How much to compress the output NetCDF file (0 is no compression, 9 is maximum compression).\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaDiagnostics.Writers.HDF5Writer","page":"APIs","title":"ClimaDiagnostics.Writers.HDF5Writer","text":"HDF5Writer()\n\nSave a ScheduledDiagnostic to a HDF5 file inside the output_dir of the simulation.\n\nTODO: This is a very barebone HDF5Writer!\n\nWe need to implement the following features/options:\n\nToggle for write new files/append\nChecks for existing files\nCheck for new subfolders that have to be created\nMore meaningful naming conventions (keeping in mind that we can have multiple variables with different reductions)\nAll variables in one file/each variable in its own file\nAll timesteps in one file/each timestep in its own file\nWriting the correct attributes\nOverriding simulation.output_dir (e.g., if the path starts with /)\n...more features/options\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaDiagnostics.Writers.write_field!","page":"APIs","title":"ClimaDiagnostics.Writers.write_field!","text":"write_field!(writer::DictWriter, field, diagnostic, u, p, t)\n\nAdd an entry to the writer at time t for the current diagnostic with value field.\n\nDictWriter is backed by a dictionary. Most typically, the keys of this dictionary are either strings, the output_short_name of the diagnostic. If the output_short_name is not available, use the diagnostic itself. The values of this dictionary is another dictionary that maps the time t to the field at that value.\n\nDictWriter implements a basic read-only dictionary interface to access the times and values.\n\n\n\n\n\nwrite_field!(writer::NetCDFWriter, field::Fields.Field, diagnostic, u, p, t)\n\nResample field and save it to file as directed by the writer.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.close","page":"APIs","title":"Base.close","text":"close(writer::HDF5Writer)\n\nClose all the files open in writer. (Currently no-op.)\n\n\n\n\n\nclose(writer::NetCDFWriter)\n\nClose all the open files in writer.\n\n\n\n\n\n","category":"function"},{"location":"user_guide/#What-do-I-have-to-do-to-use-ClimaDiagnostics?","page":"User guide","title":"What do I have to do to use ClimaDiagnostics?","text":"","category":"section"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"In this page, we describe the low level interface that ClimaDiagnostics offers to work with diagnostics. Most packages implement addition interface to streamline computing and outputting diagnostics, so you should first refer to the manual of your package of interest. Come back here if you want to go beyond what the package developers offer and unlock the full power of ClimaDiagnostics.","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"There are two fundamental objects in ClimaDiagnostics: the DiagnosticVariable, and the ScheduledDiagnostic.","category":"page"},{"location":"user_guide/#DiagnosticVariables","page":"User guide","title":"DiagnosticVariables","text":"","category":"section"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"A DiagnosticVariable is a recipe on how to compute something alongside with some metadata.","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"For example, a DiagnosticVariable might be the air temperature. In pseudocode, some of the information we might want to include attach to the air temperature are:","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"short_name: \"ta\"\nlong_name: \"Air Temperature\"\nunits: \"K\"\nhow_to_compute: state.ta\n...","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"The definition of what a DiagnosticVariable is. Conceptually, a DiagnosticVariable is a variable we know how to compute from the state. We attach more information to it for documentation and to reference to it with its short name. DiagnosticVariables can exist irrespective of the existence of an actual simulation that is being run. Science packages are encourage to define their set of pre-made DiagnosticVariables, for example, ClimaAtmos comes with several diagnostics already defined (in the ALL_DIAGNOSTICS dictionary).","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"Let us see how we would define a DiagnosticVariable","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"import ClimaDiagnostics: DiagnosticVariable\n\nfunction compute_ta!(out, state, cache, time)\n    if isnothing(out)\n        return copy(state.ta)\n    else\n        out .= state.ta\n    end\nend\n\nvar = DiagnosticVariable(;\n    short_name = \"ta\",\n    long_name = \"Air Temperature\",\n    standard_name = \"air_temperature\",\n    comments = \"Measured assuming that the air is in quantum equilibrium with the metaverse\",\n    units = \"K\",\n    compute! = compute_ta!\n)","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"compute_ta! is the key function here. It determines how the variable should be computed from the state, cache, and time of the simulation. Typically, these are packaged within an integrator object (e.g., state = integrator.u or integrator.Y).","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"compute_ta! takes another argument, out. out is an area of memory managed by ClimaDiagnostics that is used to reduce the number of allocations needed when working with diagnostics. The first time the diagnostic is called, an area of memory is allocated and filled with the value (this is when out is nothing). All the subsequent times, the same space is overwritten, leading to much better performance. You should follow this pattern in all your diagnostics.","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"Note, in the future, we hope to improve this rather clumsy way to write diagnostics. Hopefully, at some you will just have to write something like state.ta and not worry about the out at all.","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"A DiagnosticVariable defines what a variable is and how to compute it, but does not specify when to compute/output it. For that, we need ScheduledDiagnostics.","category":"page"},{"location":"user_guide/#ScheduledDiagnostics","page":"User guide","title":"ScheduledDiagnostics","text":"","category":"section"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"A ScheduledDiagnostic is a DiagnosticVariable with attached a schedule on when it should be computed and output, as well as what reductions should be performed and how the file should be written.","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"Continuing our example on ta. Suppose we want to compute the average of the air temperature over a month. We would package this in a ScheduledDiagnostic that knows that we want to compute the air temperature, and we want it averaged over a month.","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"Let us examine what is in a ScheduledDiagnostic in more details:","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"variable, the DiagnosticVariable we want to compute.\ntwo schedule functions that determine when the variable should be computed and output (compute_schedule_func and output_schedule_func). We have two separate entries one for compute and one for output because we might want to control them separately. For instance, we might want to take the average of something every 10 steps, and output it the average every 100 iterations. schedule functions are powerful, so there is an entire section dedicated to them below. compute_schedule_func and output_schedule_func are likely going to the same unless there are temporal reductions.\nan output_writer, an object that knows how what to do with the output. Examples of writers might be the DictWriter, which saves the output to a dictionary, or the NetCDFWriter, which saves the output to NetCDF files. A more complete description of the available writers is in Saving the diagnostics page.\noutput_short_name and output_long_name, two strings that specify the names that should be used for the output. Typically, output_short_name is used for file/key names, output_long_name is used for descriptive attributes. If none is provided, one is automatically generated by the output_short_name and output_long_name functions.\nreduction_time_func, a function that implements a temporal reduction. Discussed later. This is what you need to implement operations like arithmetic averages. A pre_output_hook! function can also be passed to do some basic normalization operations.","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"Note that we can have multiple ScheduledDiagnostics for the same DiagnosticVariable (e.g., daily and monthly average temperatures).","category":"page"},{"location":"user_guide/#Schedules","page":"User guide","title":"Schedules","text":"","category":"section"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"ScheduledDiagnostics contain two arguments compute_schedule_func and output_schedule_func which dictate when the variable should be computed and when it should be output.","category":"page"},{"location":"user_guide/#Temporal-reductions","page":"User guide","title":"Temporal reductions","text":"","category":"section"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"It is often useful to compute aggregate data (e.g., monthly averages). In ClimaDiagnostics, this is implemented with through temporal reductions.","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"Let us assume we want to compute the maximum of the air temperature within a month. To achieve this, we simply pass the max function to reduction_time_func and choose our window in the output_schedule_func.","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"The only temporal reductions allowed are ones defined by associative operations, that is, functions f so that f(a, b, c, d, ...) = f(a, f(b, f(c, f(d, ...)))) (such as the sum). The reason for this restriction comes from the fact that we do not store all the intermediate values (which would lead to large consumption of memory). Instead, we accumulate intermediate results. So, the only statistics that can be computed are the ones that can be computed by adding one element at the time.","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"More specifically, when a ScheduledDiagnostic is created with a reduction_time_func, ClimaDiagnostics allocates an extra area of space accumulated for the accumulated value. Every time compute_schedule_func is true, the DiagnosticVariable is computed and saved to out. Then, accumulated is updated with the return value of reduction_time_func(accumulated, out). When output_schedule_func is true, the accumulated value is written with the writer and the state reset to the neutral state.","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"To allow for greater flexibility, ClimaDiagnostics also provides the option to evaluate a function before the output is saved.","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"Pseudo code:","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"At the end of every time step:\n    if compute_schedule_func is true:\n        out = compute!\n        if reduction_time_func is not nothing:\n            accumulated_value = reduction_time_func(accumulated_value, out)\n            counter += 1\n    if output_schedule_func is true:\n        pre_output_hook(accumulated_value, counter)\n        dump(accumulated_value)\n        reset(accumulated_value)\n        reset(counter)","category":"page"},{"location":"developer_guide/#I-am-a-developer,-how-do-I-add-ClimaDiagnostics.jl-to-my-package?","page":"How to add ClimaDiagnostics to a package","title":"I am a developer, how do I add ClimaDiagnostics.jl to my package?","text":"","category":"section"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"Before reading this section, make sure you are familiar with the terminology. You know to know what a DiagnosticVariable and a ScheduledDiagnostic are.","category":"page"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"There are three components needed to add support for ClimaDiagnostics.jl in your package.","category":"page"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"A way to convert users' intentions to a list of ScheduledDiagnostic\nA call to DiagnosticsHandler after the initial state Y and cache p are prepared. This initializes the diagnostics and creates an object DiagnosticsHandler.\nAdding DiagnosticsCallback(DiagnosticsHandler) to the SciML integrator.","category":"page"},{"location":"developer_guide/#An-example-for-steps-2.-and-3.","page":"How to add ClimaDiagnostics to a package","title":"An example for steps 2. and 3.","text":"","category":"section"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"Let us assume that scheduled_diagnostics is the list of ScheduledDiagnostics obtained from step 1. (more on this later), Y is the simulation initial state, p, the cache, t0 the initial time, and dt the timestep.","category":"page"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"Schematically, what we need to do is","category":"page"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"import ClimaDiagnostics: DiagnosticsHandler, DiagnosticsCallback\n\n# Initialize the diagnostics, can be expensive\ndiagnostic_handler = ClimaDiagnostics.DiagnosticsHandler(\n        scheduled_diagnostics,\n        Y,\n        p,\n        t0;\n        dt,\n    )\n\n# Prepare the SciML callback\ndiag_cb = ClimaDiagnostics.DiagnosticsCallback(diagnostic_handler)\n\nSciMLBase.init(args...; kwargs..., callback = diag_cb)","category":"page"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"with args and kwargs the argument and keyword argument needed to set up the target simulation.","category":"page"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"In DiagnosticsHandler, dt is used exclusively for consistency checks. Suppose your timestep is 50s and you request a variable to be output every 70s, if you pass dt, DiagnosticsHandler will catch this and error out. If you don't pass dt, DiagnosticsHandler will warn you about that.","category":"page"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"Creating a DiagnosticsHandler results in calling all the diagnostics once. Therefore, the compile and runtime of this function can be significant if you have a large number of diagnostics.","category":"page"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"You can learn about what is happening under the hook in the Internals page.","category":"page"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"This is pretty much all that you need to know about steps 2 and 3!","category":"page"},{"location":"developer_guide/#Step-1","page":"How to add ClimaDiagnostics to a package","title":"Step 1","text":"","category":"section"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"Step 1 in the recipe to bring ClimaDiagnostics to your package strongly depends on you.","category":"page"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"In this section, I will present a tower of interfaces that you can put in place to make it more convenient for your users. Keep in mind that each layer trades more convenience for less flexibility. So, as you set up your interfaces, I recommend you keep them exposed so that your users can access lower-level functions if they need to.","category":"page"},{"location":"developer_guide/#Level-0:-do-nothing","page":"How to add ClimaDiagnostics to a package","title":"Level 0: do nothing","text":"","category":"section"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"At the zero-th level, you let your users work directly with ClimaDiagnostics. This means that they will have to define their own DiagnosticVariables and ScheduledDiagnostics. This also requires that your simulation is executed as a julia script.","category":"page"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"It is a good idea for your users to be aware of this possibility because it brings enormous power. ScheduledDiagnostics can be triggered on arbitrary conditions, and your users could be creative with that. For example, users might want to compute and output a variable var1 when they find that the maximum of variable var2 is greater than a threshold (e.g., for debugging).","category":"page"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"Let us see the simplest example to accomplish this","category":"page"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"import ClimaDiagnostics: DiagnosticVariable, ScheduledDiagnostic\nimport ClimaDiagnostics.Writers: DictWriter\n\nmyvar = DiagnosticVariable(; compute! = (out, u, p, t) -> u.var1)\n\nmyschedule = (integrator) -> maximum(integrator.u.var2) > 10.0\n\ndiag = ScheduledDiagnostic(variable = myvar,\n                           compute_schedule_func = myschedule,\n                           output_schedule_func = myschedule,\n                           output_writer = DictWriter())","category":"page"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"Now we can go to step 2 and 3 in the previous list and pass [diag] to the DiagnosticsHandler.","category":"page"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"Point your users to the documentation of this package for them to learn how to use it in its full power.","category":"page"},{"location":"developer_guide/#Level-1:-provide-a-database-of-DiagnosticVariables","page":"How to add ClimaDiagnostics to a package","title":"Level 1: provide a database of DiagnosticVariables","text":"","category":"section"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"As a package developer, you know that there is a large collection of variables that several users will be interested in. For example, if you are running an atmospheric simulation, your users will want to be able to look at the air temperature. For this reason, it is a very good (and user-friendly) idea to provide a collection of DiagnosticVariables ready to be used. In this section, I sketch how you could go about and implement this.","category":"page"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"Your DiagnosticVariables database can be represented as a dictionary ALL_DIAGNOSTICS indexed over the short name of the variable. Then, you could provide adders and accessors.","category":"page"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"This might look like the following:","category":"page"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"module Diagnostics\nimport ClimaDiagnostics: DiagnosticVariable\n\nconst ALL_DIAGNOSTICS = Dict{String, DiagnosticVariable}()\n\n\"\"\"\n\n    add_diagnostic_variable!(; short_name,\n                               long_name,\n                               standard_name,\n                               units,\n                               description,\n                               compute!)\n\n\nAdd a new variable to the `ALL_DIAGNOSTICS` dictionary (this function mutates the state of\n`ALL_DIAGNOSTICS`).\n\nIf possible, please follow the naming scheme outline in\nhttps://airtable.com/appYNLuWqAgzLbhSq/shrKcLEdssxb8Yvcp/tblL7dJkC3vl5zQLb\n\nKeyword arguments\n=================\n\n- `short_name`: Name used to identify the variable in the output files and in the file\n                names. Short but descriptive. Diagnostics are identified by the short name.\n\n- `long_name`: Name used to identify the variable in the output files.\n\n- `standard_name`: Standard name, as in\n                   http://cfconventions.org/Data/cf-standard-names/71/build/cf-standard-name-table.html\n\n- `units`: Physical units of the variable.\n\n- `comments`: More verbose explanation of what the variable is, or comments related to how\n              it is defined or computed.\n\n- `compute!`: Function that compute the diagnostic variable from the state. It has to take\n              two arguments: the `integrator`, and a pre-allocated area of memory where to\n              write the result of the computation. It the no pre-allocated area is\n              available, a new one will be allocated. To avoid extra allocations, this\n              function should perform the calculation in-place (i.e., using `.=`).\n\n\"\"\"\nfunction add_diagnostic_variable!(;\n    short_name,\n    long_name,\n    standard_name = \"\",\n    units,\n    comments = \"\",\n    compute!,\n)\n    haskey(ALL_DIAGNOSTICS, short_name) && @warn(\n        \"overwriting diagnostic `$short_name` entry containing fields\\n\" *\n        \"$(map(\n            field -> \"$(getfield(ALL_DIAGNOSTICS[short_name], field))\",\n            # We cannot really compare functions...\n            filter(field -> field != :compute!, fieldnames(DiagnosticVariable)),\n        ))\"\n    )\n\n    ALL_DIAGNOSTICS[short_name] = DiagnosticVariable(;\n        short_name,\n        long_name,\n        standard_name,\n        units,\n        comments,\n        compute!,\n    )\n\n\"\"\"\n    get_diagnostic_variable!(short_name)\n\nReturn a `DiagnosticVariable` from its `short_name`, if it exists.\n\"\"\"\nfunction get_diagnostic_variable(short_name)\n    haskey(ALL_DIAGNOSTICS, short_name) ||\n        error(\"diagnostic $short_name does not exist\")\n\n    return ALL_DIAGNOSTICS[short_name]\nend\n\nend","category":"page"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"Of course, you should have the fields and comments that are relevant to your package.","category":"page"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"Next, as a developer, you will use add_diagnostic_variable! to populate your database. You can also expose your users to this function so that they can extend their personal database in their simulations.","category":"page"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"A simple example of a new variable might look like","category":"page"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"###\n# Density (3d)\n###\nadd_diagnostic_variable!(\n    short_name = \"rhoa\",\n    long_name = \"Air Density\",\n    standard_name = \"air_density\",\n    units = \"kg m^-3\",\n    compute! = (out, state, cache, time) -> begin\n        if isnothing(out)\n            return copy(state.c.ρ)\n        else\n            out .= state.c.ρ\n        end\n    end,\n)","category":"page"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"It is a good idea to put safeguards in place to ensure that your users will not be allowed to call diagnostics that do not make sense for the simulation they are running. If your package has a notion of Model that is stored in p, you can dispatch over that and return an error. A simple example might be","category":"page"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"###\n# Specific Humidity\n###\ncompute_hus!(out, state, cache, time) =\n    compute_hus!(out, state, cache, time, cache.atmos.moisture_model)\n\ncompute_hus!(out, state, cache, time) =\n    compute_hus!(out, state, cache, time, cache.model.moisture_model)\ncompute_hus!(_, _, _, _, model::T) where {T} =\n    error(\"Cannot compute hus with $model\")\n\nfunction compute_hus!(\n    out,\n    state,\n    cache,\n    time,\n    moisture_model::T,\n) where {T <: Union{EquilMoistModel, NonEquilMoistModel}}\n    if isnothing(out)\n        return state.c.ρq_tot ./ state.c.ρ\n    else\n        out .= state.c.ρq_tot ./ state.c.ρ\n    end\nend\n\nadd_diagnostic_variable!(\n    short_name = \"hus\",\n    long_name = \"Specific Humidity\",\n    standard_name = \"specific_humidity\",\n    units = \"kg kg^-1\",\n    comments = \"Mass of all water phases per mass of air\",\n    compute! = compute_hus!,\n)","category":"page"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"This relies on dispatching over moisture_model. If model is not in Union{EquilMoistModel, NonEquilMoistModel}, the code returns an informative error.","category":"page"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"If you provide a database, users can create their ScheduledDiagnostics directly from the DiagnosticVariables you provided.","category":"page"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"For instance to output the specific humidity every 5 iterations:","category":"page"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"import ClimaDiagnostics: ScheduledDiagnostic\nimport ClimaDiagnostics.Callbacks: DivisorSchedule\nimport ClimaDiagnostics.Writers: DictWriter\n\ndiag = ScheduledDiagnostic(variable = get_diagnostic_variable!(\"hus\"),\n                           output_schedule_func = DivisorSchedule(5),\n                           output_writer = DictWriter())","category":"page"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"Alongside with providing the DiagnosticVariables, you can also provide convenience functions for standard operations.","category":"page"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"For example, you could provide","category":"page"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"using ClimaDiagnostics.Callbacks: EveryStepSchedule, EveryDtSchedule\n\nfunction monthly_average(short_name; output_writer, t_start)\n    period = 30 * 24 * 60 * 60 * one(t_start)\n    return ScheduledDiagnostic(\n            variable = get_diagnostic_variable(short_name),\n            compute_schedule_func = EveryStepSchedule(),\n            output_schedule_func = EveryDtSchedule(period; t_start),\n            reduction_time_func = (+),\n            output_writer = output_writer,\n            pre_output_hook! = average_pre_output_hook!,\n        )\nend","category":"page"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"Allowing users to just call monthly_average(\"hus\", writer, t_start).","category":"page"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"Note: ClimaDiagnostics will probably provided these schedules natively at some point in the future.","category":"page"},{"location":"developer_guide/#Level-2:-Provide-defaults","page":"How to add ClimaDiagnostics to a package","title":"Level 2: Provide defaults","text":"","category":"section"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"Once you built your database of variables, it is a good idea to provide reasonable defaults too.","category":"page"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"TODO: Fill this","category":"page"},{"location":"developer_guide/#Level-3:-Provide-higher-level-interfaces-(e.g.,-YAML)","page":"How to add ClimaDiagnostics to a package","title":"Level 3: Provide higher-level interfaces (e.g., YAML)","text":"","category":"section"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"Finally, you can set in place that parses user input (e.g., from command line or text files) into ScheduledDiagnostics using the short names in your database. Of course, this interface will be limited to what you expose.","category":"page"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"For example, a simple parser that allow users to specify ScheduledDiagnostics by their short name, accumulation/output period, and their writer might look like the following:","category":"page"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"import ClimaDiagnostics: average_pre_output_hook!, HDF5Writer, NetCDFWriter, ScheduledDiagnostic\n\nfunction parse_yaml(parsed_args, target_space)\n    # We either get the diagnostics section in the YAML file, or we return an empty list\n    # (which will result in an empty list being created by the map below)\n    yaml_diagnostics = get(parsed_args, \"diagnostics\", [])\n\n    # ALLOWED_REDUCTIONS is the collection of reductions we support. The keys are the\n    # strings that have to be provided in the YAML file. The values are tuples with the\n    # function that has to be passed to reduction_time_func and the one that has to passed\n    # to pre_output_hook!\n\n    # We make \"nothing\" a string so that we can accept also the word \"nothing\", in addition\n    # to the absence of the value\n    #\n    # NOTE: Everything has to be lowercase in ALLOWED_REDUCTIONS (so that we can match\n    # \"max\" and \"Max\")\n    ALLOWED_REDUCTIONS = Dict(\n        \"nothing\" => (nothing, nothing), # nothing is: just dump the variable\n        \"max\" => (max, nothing),\n        \"min\" => (min, nothing),\n        \"average\" => ((+), average_pre_output_hook!),\n    )\n\n    output_dir = parsed_args.output_dir\n\n    hdf5_writer = HDF5Writer(output_dir)\n    netcdf_writer = CAD.NetCDFWriter(\n        target_space,\n        output_dir,\n    )\n    writers = (hdf5_writer, netcdf_writer)\n\n    # The default writer is HDF5\n    ALLOWED_WRITERS = Dict(\n        \"nothing\" => netcdf_writer,\n        \"h5\" => hdf5_writer,\n        \"hdf5\" => hdf5_writer,\n        \"nc\" => netcdf_writer,\n        \"netcdf\" => netcdf_writer,\n    )\n\n    diagnostics_ragged = map(yaml_diagnostics) do yaml_diag\n        short_names = yaml_diag[\"short_name\"]\n        output_name = get(yaml_diag, \"output_name\", nothing)\n\n        map(short_names) do short_name\n            # Return \"nothing\" if \"reduction_time\" is not in the YAML block\n            #\n            # We also normalize everything to lowercase, so that can accept \"max\" but\n            # also \"Max\"\n            reduction_time_yaml =\n                lowercase(get(yaml_diag, \"reduction_time\", \"nothing\"))\n\n            if !haskey(ALLOWED_REDUCTIONS, reduction_time_yaml)\n                error(\"reduction $reduction_time_yaml not implemented\")\n            else\n                reduction_time_func, pre_output_hook! =\n                    ALLOWED_REDUCTIONS[reduction_time_yaml]\n            end\n\n            writer_ext = lowercase(get(yaml_diag, \"writer\", \"nothing\"))\n\n            if !haskey(ALLOWED_WRITERS, writer_ext)\n                error(\"writer $writer_ext not implemented\")\n            else\n                writer = ALLOWED_WRITERS[writer_ext]\n            end\n\n            haskey(yaml_diag, \"period\") ||\n                error(\"period keyword required for diagnostics\")\n\n            period_seconds = FT(time_to_seconds(yaml_diag[\"period\"]))\n\n            if isnothing(reduction_time_func)\n                compute_every = CAD.EveryDtSchedule(period_seconds; t_start)\n            else\n                compute_every = CAD.EveryStepSchedule()\n            end\n\n            ScheduledDiagnostic(\n                variable = get_diagnostic_variable(short_name),\n                output_schedule_func = CAD.EveryDtSchedule(period_seconds; t_start),\n                compute_schedule_func = compute_every,\n                reduction_time_func = reduction_time_func,\n                pre_output_hook! = pre_output_hook!,\n                output_writer = writer,\n            )\n        end\n    end\n\n    # Flatten the array of arrays of diagnostics\n    diagnostics = vcat(diagnostics_ragged...)\nend","category":"page"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"This will be controlled by YAML blocks like","category":"page"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"diagnostics:\n    - short_name: [\"ta\", \"va\"]\n      period: 60s\n      writer: nc\n    - short_name: [\"ua\"]\n      period: 1200s\n      reduction_time: \"average\"","category":"page"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"It is typically a good idea to add the default diagnostics to the set of YAML-specified ones.","category":"page"},{"location":"developer_guide/#API","page":"How to add ClimaDiagnostics to a package","title":"API","text":"","category":"section"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"ClimaDiagnostics.DiagnosticsHandler\nClimaDiagnostics.DiagnosticsCallback","category":"page"},{"location":"#ClimaDiagnostics.jl","page":"Overview","title":"ClimaDiagnostics.jl","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"ClimaDiagnostics.jl is a module that adds diagnostics to your CliMA simulations. Diagnostics are variables that are computed from your state when specific conditions are met (typically at set intervals of time) throughout the run and typically saved to disk.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"ClimaDiagnostics.jl provides the infrastructure to schedule, compute, reduce, and output such variables.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"If you are a user of a package that is already using ClimaDiagnostics.jl, you can jump to the User guide page.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"If you are a developer interested in adding support for ClimaDiagnostics.jl in your package or learning about the internal design of this package, please read the Developer guide page.","category":"page"},{"location":"#Features","page":"Overview","title":"Features","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"Accumulate diagnostics over period of times with associative binary temporal reductions (eg, averages);\nAllow users to define arbitrary new diagnostics;\nTrigger diagnostics on arbitrary conditions;\nSave output to HDF5 or NetCDF files, or a dictionary in memory;","category":"page"},{"location":"internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"There are multiple moving parts to this package. In this page, we describe the internal design.","category":"page"},{"location":"internals/#The-callback-system","page":"Internals","title":"The callback system","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"Diagnostics are implemented as callbacks to the integrator that are called at the end of integration steps. ClimaDiagnostics implements its own system to manage callbacks. The centerpiece of this is the CallbackOrchestrator, a master callback that is unconditionally executed at the end of each step. CallbackOrchestrator loops over each registered callback function, executing the ones for which the trigger condition is met.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"The callbacks registered with CallbackOrchestrator are Callback objects (in the Callbacks module). Callbacks are simple struct that hold two pieces of information: the function that has to be executed, and the condition that has to be met to call such function.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Schematically, a Callback is","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"struct Callback\n    \"\"\"Function to be called. It has to take one argument, the integrator.\"\"\"\n    callback_func::FUNC\n\n    \"\"\"Boolean function (or, more often, a callable struct, e.g., an `AbstractSchedule`) that\n    determines whether `callback_func` should be called or not. It has to take one argument,\n    the integrator. Most typically, only `integrator.t` or `integrator.step` are used.\"\"\"\n    schedule_func::SCHEDULE\nend","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"At the end of each step CallbackOrchestrator calls schedules_func, when it returns true, it calls callback_func too.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Most often, schedules_func are not simple functions, but callable objects (subtypes of AbstractSchedule). There are two reasons for this:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Most realistic schedules need to hold additional data (e.g., the last time the function was called)\nWe want to attach names to use in the output","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Most of the details regarding schedules are described in the user guide. An internal detail that is not there is related to names. We define a method for show for AbstractSchedules. This method calls the short_name function.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Base.show(io::IO, schedule::AbstractSchedule) =  print(io, short_name(schedule))","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"This allows us to set names of ScheduledDiagnostics with \"$schedule_func\" in both the case schedule_func is a normal function, or an AbstractSchedule.","category":"page"},{"location":"internals/#Accumulation","page":"Internals","title":"Accumulation","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"Several diagnostics require performing reductions, such as taking the maximum or the average. Since it is not feasible to store all the lists of all the intermediate values, we aggregate the results in specific storage areas (e.g., we take max(max(max(max(t1, t2), t3), t4), t5) instead of max(t1, t2, t3, t4, t5) In this, it is convenient to preallocate the space where we want to accumulate the intermediate.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Accumulation is accomplished by the accumulate! function. All this function does is applying the binary reduction_time_func to the previous accumulated value and the newly computed one and store the output to the accumulator.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"After an accumulated variable is output, the accumulator is reset to its natural state. This is achieved with the reset_accumulator! function.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"However, we have to fill the space with something that does not affect the reduction. This, by definition, is the identity of the operation. The identity of the operation + is 0 because x + 0 = x for every x.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"We have to know the identity for every operation we want to support. Of course, users are welcome to define their own by adding new methods to identityofreduction.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"For instance, to define the identity of the reduction -, one would write","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"function ClimaDiagnostics.Diagnostics.identity_of_reduction(::typeof(-))\n    return 0\nend","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"(Or add this to the reduction_identities.jl file.)","category":"page"}]
}
