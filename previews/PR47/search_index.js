var documenterSearchIndex = {"docs":
[{"location":"writers/#Saving-the-diagnostics","page":"Saving output","title":"Saving the diagnostics","text":"","category":"section"},{"location":"writers/","page":"Saving output","title":"Saving output","text":"Writers are needed to save the computed diagnostics.","category":"page"},{"location":"writers/","page":"Saving output","title":"Saving output","text":"ClimaDiagnostics comes with three writers:","category":"page"},{"location":"writers/","page":"Saving output","title":"Saving output","text":"NetCDFWriter, to interpolate and save to NetCDF files;\nDictWriter, to save Fields to dictionaries in memory;\nHDF5Writer, to save Fields to HDF5 files.","category":"page"},{"location":"writers/","page":"Saving output","title":"Saving output","text":"(There is an additional DummyWriter that does nothing. It is mostly used internally for testing and debugging.)","category":"page"},{"location":"writers/","page":"Saving output","title":"Saving output","text":"Users are welcome to implement their own writers. A writer has to be a subtype of AbstractWriterand has to implement the interpolate_field! and write_field! methods. interpolate_field! can return nothing is no interpolation is needed.","category":"page"},{"location":"writers/#NetCDFWriter","page":"Saving output","title":"NetCDFWriter","text":"","category":"section"},{"location":"writers/","page":"Saving output","title":"Saving output","text":"The NetCDFWriter resamples the input Field to a rectangular grid and saves the output to a NetCDF file.","category":"page"},{"location":"writers/","page":"Saving output","title":"Saving output","text":"The NetCDFWriter relies on the Remappers module in ClimaCore to interpolate onto the rectangular grid. Horizontally, this interpolation is a Lagrange interpolation, vertically, it is a linear. This interpolation is not conservative. Also note that, the order of vertical interpolation drops to zero in the first and last vertical elements of each column.","category":"page"},{"location":"writers/","page":"Saving output","title":"Saving output","text":"To create a NetCDFWriter, you need to specify the target ClimaCore Space and the output directory where the files should be saved. By default, the NetCDFWriter appends to existing files and create new ones if they do not exist. The NetCDFWriter does not overwrite existing data and will error out if existing data is inconsistent with the new one.","category":"page"},{"location":"writers/","page":"Saving output","title":"Saving output","text":"NetCDFWriters take as one of the inputs the desired number of points along each of the dimensions. For the horizontal dimensions, points are sampled linearly. For the vertical dimension, the behavior can be customized by passing the z_sampling_method variable. When z_sampling_method = ClimaDiagnostics.Writers.LevelMethod(), points evaluated on the grid levels (and the provided number of points ignored), when z_sampling_method = ClimaDiagnostics.Writers.FakePressureLevelMethod(), points are sampled uniformly in simplified hydrostatic atmospheric model.","category":"page"},{"location":"writers/","page":"Saving output","title":"Saving output","text":"The output in the NetCDFWriter roughly follows the CF conventions.","category":"page"},{"location":"writers/","page":"Saving output","title":"Saving output","text":"Each ScheduledDiagnostic is output to a different file with name determined by calling the output_short_name on the ScheduledDiagnostic. Typically, these files have names like ta_1d_max.nc, ha_20s_inst.nc, et cetera. The files define their dimensions (lon, lat, z, ...). Time is always the first dimension is any dataset.","category":"page"},{"location":"writers/","page":"Saving output","title":"Saving output","text":"Do not forget to close your writers to avoid file corruption!","category":"page"},{"location":"writers/","page":"Saving output","title":"Saving output","text":"To help reducing data loss, NetCDFWriter can force syncing, i.e. flushing the values to disk. Usually, NetCDF buffers writes to disk (because they are expensive), meaning values are not immediately written but are saved to disk in batch. This can result in data loss, and it is often useful to force NetCDF to write to disk (this is especially the case when working with GPUs). To do so, you can pass the sync_schedule function to the constructor of NetCDFWriter. When not nothing, sync_schedule is a callable that takes one argument (the integrator) and returns a bool. When the bool is true, the files that were modified since the last sync will be synced. For example, to force sync every 1000 steps, you can pass the ClimaDiagnostics.Schedules.DivisorSchedule(1000) schedule. By default, on GPUs, we call sync at the end of every time step for those files that need to be synced.","category":"page"},{"location":"writers/","page":"Saving output","title":"Saving output","text":"Variables are saved as datasets with attributes, where the attributes include long_name, standard_name, units...","category":"page"},{"location":"writers/","page":"Saving output","title":"Saving output","text":"ClimaDiagnostics.Writers.NetCDFWriter\nClimaDiagnostics.Writers.interpolate_field!\nClimaDiagnostics.Writers.write_field!\nClimaDiagnostics.Writers.sync\nBase.close","category":"page"},{"location":"writers/#ClimaDiagnostics.Writers.sync","page":"Saving output","title":"ClimaDiagnostics.Writers.sync","text":"sync(writer::NetCDFWriter)\n\nCall NCDatasets.sync on all the files in the writer.unsynced_datasets list. NCDatasets.sync ensures that the values are written to file.\n\n\n\n\n\n","category":"function"},{"location":"writers/","page":"Saving output","title":"Saving output","text":"Sampling methods for the vertical direction:","category":"page"},{"location":"writers/","page":"Saving output","title":"Saving output","text":"ClimaDiagnostics.Writers.AbstractZSamplingMethod\nClimaDiagnostics.Writers.LevelsMethod\nClimaDiagnostics.Writers.FakePressureLevelsMethod\nBase.close","category":"page"},{"location":"writers/#ClimaDiagnostics.Writers.AbstractZSamplingMethod","page":"Saving output","title":"ClimaDiagnostics.Writers.AbstractZSamplingMethod","text":"AbstractZSamplingMethod\n\nThe AbstractZInterpolationMethod defines how points along the vertical axis should be sampled.\n\nIn other words, if a column is defined between 0 and 100 and the target number of points is\n\nHow should those 50 points be chosen?\n\nAvailable methods are:\n\nLevelMethod: just use the grid levels\nFakePressureLevelsMethod: linearly spaced in (very) approximate atmospheric pressure levels\n\n\n\n\n\n","category":"type"},{"location":"writers/#ClimaDiagnostics.Writers.LevelsMethod","page":"Saving output","title":"ClimaDiagnostics.Writers.LevelsMethod","text":"LevelsMethod\n\nDo not perform interpolation on z, use directly the grid levels instead.\n\n\n\n\n\n","category":"type"},{"location":"writers/#ClimaDiagnostics.Writers.FakePressureLevelsMethod","page":"Saving output","title":"ClimaDiagnostics.Writers.FakePressureLevelsMethod","text":"FakePressureLevelsMethod\n\nLinearly sample points from z_min to z_max in pressure levels assuming a very simplified hydrostatic balance model.\n\nPressure is approximated with\n\np ~ p₀ exp(-z/H)\n\nH is assumed to be 7000 m, which is a good scale height for the Earth atmosphere.\n\n\n\n\n\n","category":"type"},{"location":"writers/#DictWriter","page":"Saving output","title":"DictWriter","text":"","category":"section"},{"location":"writers/","page":"Saving output","title":"Saving output","text":"The DictWriter is a in-memory writer that is particularly useful for interactive work and debugging.","category":"page"},{"location":"writers/","page":"Saving output","title":"Saving output","text":"ClimaDiagnostics.Writers.DictWriter\nClimaDiagnostics.Writers.write_field!","category":"page"},{"location":"writers/#HDF5Writer","page":"Saving output","title":"HDF5Writer","text":"","category":"section"},{"location":"writers/","page":"Saving output","title":"Saving output","text":"The HDF5Writer writes the Field directly to an HDF5 file in such a way that it can be later read and imported using the InputOutput module in ClimaCore.","category":"page"},{"location":"writers/","page":"Saving output","title":"Saving output","text":"The HDF5Writer writes one file per variable per timestep. The name of the file is determined by the output_short_name field of the ScheduledDiagnostic that is being output.","category":"page"},{"location":"writers/","page":"Saving output","title":"Saving output","text":"Note: The HDF5Writer in ClimaDiagnostics is currently the least developed one. If you need this writer, we can expand it.","category":"page"},{"location":"writers/","page":"Saving output","title":"Saving output","text":"ClimaDiagnostics.Writers.HDF5Writer\nClimaDiagnostics.Writers.write_field!","category":"page"},{"location":"api/#Public-APIs","page":"APIs","title":"Public APIs","text":"","category":"section"},{"location":"api/#ClimaDiagnostics","page":"APIs","title":"ClimaDiagnostics","text":"","category":"section"},{"location":"api/","page":"APIs","title":"APIs","text":"ClimaDiagnostics.IntegratorWithDiagnostics","category":"page"},{"location":"api/#ClimaDiagnostics.IntegratorWithDiagnostics","page":"APIs","title":"ClimaDiagnostics.IntegratorWithDiagnostics","text":"IntegratorWithDiagnostics(integrator,\n                          scheduled_diagnostics)\n\nReturn a new integrator with diagnostics defined by scheduled_diagnostics.\n\nIntegratorWithDiagnostics is conceptually similar to defining a DiagnosticsHandler, constructing its associated DiagnosticsCallback, and adding such callback to a given integrator.\n\nThe new integrator is identical to the previous one with the only difference that it has a new callback called after all the other callbacks to accumulate/output diagnostics.\n\nIntegratorWithDiagnostics ensures that the diagnostic callbacks are initialized and called after everything else is initialized and computed.\n\nIntegratorWithDiagnostics assumes that the state is integrator.u and the cache is integrator.p. This behavior can be customized by passing the state_name and cache_name keyword arguments.\n\n\n\n\n\n","category":"function"},{"location":"api/#Schedules","page":"APIs","title":"Schedules","text":"","category":"section"},{"location":"api/","page":"APIs","title":"APIs","text":"ClimaDiagnostics.Schedules.AbstractSchedule\nClimaDiagnostics.Schedules.short_name\nClimaDiagnostics.Schedules.long_name\nClimaDiagnostics.Schedules.DivisorSchedule\nClimaDiagnostics.Schedules.EveryStepSchedule\nClimaDiagnostics.Schedules.EveryDtSchedule\n","category":"page"},{"location":"api/#ClimaDiagnostics.Schedules.AbstractSchedule","page":"APIs","title":"ClimaDiagnostics.Schedules.AbstractSchedule","text":"AbstractSchedule\n\nAbstractSchedules are structs that behave like functions and are used for the purpose of defining a schedule to be used in ScheduledDiagnostics. They also may contain additional information.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaDiagnostics.Schedules.short_name","page":"APIs","title":"ClimaDiagnostics.Schedules.short_name","text":"short_name(schedule)\n\nShort of name of the given schedule. Typically used in names of files/datasets.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaDiagnostics.Schedules.long_name","page":"APIs","title":"ClimaDiagnostics.Schedules.long_name","text":"long_name(schedule)\n\nLong of name of the given schedule. Typically used in attributes.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaDiagnostics.Schedules.DivisorSchedule","page":"APIs","title":"ClimaDiagnostics.Schedules.DivisorSchedule","text":"DivisorSchedule\n\nTrue when the iteration number is evenly divisible by a given number.\n\nThis is roughly equivalent to: \"run this call back every N steps\", with the difference that no initial offset is possible.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaDiagnostics.Schedules.EveryStepSchedule","page":"APIs","title":"ClimaDiagnostics.Schedules.EveryStepSchedule","text":"EveryStepSchedule()\n\nReturn a schedule that executes at the end of every step.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaDiagnostics.Schedules.EveryDtSchedule","page":"APIs","title":"ClimaDiagnostics.Schedules.EveryDtSchedule","text":"EveryDtSchedule\n\nTrue every time the current time is larger than the previous time this schedule was true + Dt.\n\nNote, this function performs no checks on whether the step is aligned with dt or not.\n\n\n\n\n\n","category":"type"},{"location":"api/#DiagnosticVariables","page":"APIs","title":"DiagnosticVariables","text":"","category":"section"},{"location":"api/","page":"APIs","title":"APIs","text":"ClimaDiagnostics.DiagnosticVariables.DiagnosticVariable\nClimaDiagnostics.DiagnosticVariables.short_name\nClimaDiagnostics.DiagnosticVariables.long_name\nClimaDiagnostics.DiagnosticVariables.descriptive_short_name\nClimaDiagnostics.DiagnosticVariables.descriptive_long_name","category":"page"},{"location":"api/#ClimaDiagnostics.DiagnosticVariables.DiagnosticVariable","page":"APIs","title":"ClimaDiagnostics.DiagnosticVariables.DiagnosticVariable","text":"DiagnosticVariable(;\n    compute!,\n    short_name = \"\",\n    long_name = \"\",\n    standard_name = \"\",\n    units = \"\",\n    comments = \"\"\n)\n\nA recipe to compute a diagnostic variable from the state, along with some useful metadata.\n\nThe primary use for DiagnosticVariables is to be embedded in a ScheduledDiagnostic to compute diagnostics while the simulation is running.\n\nThe metadata is used exclusively by the output_writer in the ScheduledDiagnostic. It is responsibility of the output_writer to follow the conventions about the meaning of the metadata and their use.\n\nIn ClimaAtmos, we roughly follow the naming conventions listed in this file: https://airtable.com/appYNLuWqAgzLbhSq/shrKcLEdssxb8Yvcp/tblL7dJkC3vl5zQLb\n\nKeyword arguments\n\ncompute!: Function that compute the diagnostic variable from the state. It has to take             two arguments: the integrator, and a pre-allocated area of memory where to             write the result of the computation. It the no pre-allocated area is             available, a new one will be allocated. To avoid extra allocations, this             function should perform the calculation in-place (i.e., using .=).\nshort_name: Name used to identify the variable in the output files and in the file               names. Short but descriptive. ClimaAtmos follows the CMIP conventions and               the diagnostics are identified by the short name.\nlong_name: Name used to describe the variable in the output files.\nstandard_name: Standard name, as in                  http://cfconventions.org/Data/cf-standard-names/71/build/cf-standard-name-table.html\nunits: Physical units of the variable.\ncomments: More verbose explanation of what the variable is, or comments related to how             it is defined or computed.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaDiagnostics.DiagnosticVariables.short_name","page":"APIs","title":"ClimaDiagnostics.DiagnosticVariables.short_name","text":"short_name(dv::DiagnosticVariable)\n\nReturn the short name associated to the given DiagnosticVariable.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaDiagnostics.DiagnosticVariables.descriptive_short_name","page":"APIs","title":"ClimaDiagnostics.DiagnosticVariables.descriptive_short_name","text":"descriptive_short_name(variable::DiagnosticVariable,\n                       output_schedule_func,\n                       reduction_time_func,\n                       pre_output_hook!)\n\nReturn a compact, unique-ish, identifier generated from the given information. This function is useful for filenames and error messages.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaDiagnostics.DiagnosticVariables.descriptive_long_name","page":"APIs","title":"ClimaDiagnostics.DiagnosticVariables.descriptive_long_name","text":"descriptive_long_name(variable::DiagnosticVariable,\n                      output_every,\n                      reduction_time_func,\n                      pre_output_hook!)\n\nReturn a verbose description of the given output variable.\n\nThis function is useful for attributes in output files.\n\n\n\n\n\n","category":"function"},{"location":"api/#ScheduledDiagnostics","page":"APIs","title":"ScheduledDiagnostics","text":"","category":"section"},{"location":"api/","page":"APIs","title":"APIs","text":"ClimaDiagnostics.ScheduledDiagnostics.ScheduledDiagnostic\nClimaDiagnostics.ScheduledDiagnostics.output_short_name\nClimaDiagnostics.ScheduledDiagnostics.output_long_name","category":"page"},{"location":"api/#ClimaDiagnostics.ScheduledDiagnostics.ScheduledDiagnostic","page":"APIs","title":"ClimaDiagnostics.ScheduledDiagnostics.ScheduledDiagnostic","text":"ScheduledDiagnostic\n\nConceptually, a ScheduledDiagnostics is a DiagnosticVariable we want to compute in a given simulation. For example, it could be the temperature averaged over a day. We can have multiple ScheduledDiagnostics for the same DiagnosticVariable (e.g., daily and monthly average temperatures).\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaDiagnostics.ScheduledDiagnostics.output_short_name","page":"APIs","title":"ClimaDiagnostics.ScheduledDiagnostics.output_short_name","text":"output_short_name(sd::ScheduledDiagnostic)\n\nReturn the short name to use for output of the ScheduledDiagnostic sd.\n\n\n\n\n\n","category":"function"},{"location":"api/#ClimaDiagnostics.ScheduledDiagnostics.output_long_name","page":"APIs","title":"ClimaDiagnostics.ScheduledDiagnostics.output_long_name","text":"output_long_name(sd::ScheduledDiagnostic)\n\nReturn the long name to use for output of the ScheduledDiagnostic sd.\n\n\n\n\n\n","category":"function"},{"location":"api/#Writers","page":"APIs","title":"Writers","text":"","category":"section"},{"location":"api/","page":"APIs","title":"APIs","text":"ClimaDiagnostics.AbstractWriter\nClimaDiagnostics.Writers.DictWriter\nClimaDiagnostics.Writers.NetCDFWriter\nClimaDiagnostics.Writers.HDF5Writer\nClimaDiagnostics.Writers.interpolate_field!\nClimaDiagnostics.Writers.write_field!\nBase.close","category":"page"},{"location":"api/#ClimaDiagnostics.AbstractWriter","page":"APIs","title":"ClimaDiagnostics.AbstractWriter","text":"AbstractWriter\n\nAn object that knows how to save some output.\n\nAbstractWriters have to provide one function, write_field!\n\nThe function has to have signature write_field!(writer::Writer, field, diagnostic, u, p, t)\n\nIt is up to the Writer to implement this.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaDiagnostics.Writers.DictWriter","page":"APIs","title":"ClimaDiagnostics.Writers.DictWriter","text":"The DictWriter is a writer that does not write to disk, but to memory (in a dictionary).\n\nThis is particularly useful for testing and debugging. This is not type stable (the underlying dictionary does not know in advance what types might be used).\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaDiagnostics.Writers.NetCDFWriter","page":"APIs","title":"ClimaDiagnostics.Writers.NetCDFWriter","text":"NetCDFWriter\n\nA struct to remap ClimaCore Fields to rectangular grids and save the output to NetCDF files.\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaDiagnostics.Writers.HDF5Writer","page":"APIs","title":"ClimaDiagnostics.Writers.HDF5Writer","text":"HDF5Writer(output_dir)\n\nSave a ScheduledDiagnostic to a HDF5 file inside the output_dir.\n\nTODO: This is a very barebone HDF5Writer!\n\n\n\n\n\n","category":"type"},{"location":"api/#ClimaDiagnostics.Writers.write_field!","page":"APIs","title":"ClimaDiagnostics.Writers.write_field!","text":"write_field!(writer::DictWriter, field, diagnostic, u, p, t)\n\nAdd an entry to the writer at time t for the current diagnostic with value field.\n\nDictWriter is backed by a dictionary. Most typically, the keys of this dictionary are either strings, the output_short_name of the diagnostic. If the output_short_name is not available, use the diagnostic itself. The values of this dictionary is another dictionary that maps the time t to the field at that value.\n\nDictWriter implements a basic read-only dictionary interface to access the times and values.\n\n\n\n\n\nHDF5Writer(output_dir)\n\nSave a ScheduledDiagnostic to a HDF5 file inside the output_dir.\n\nThe name of the file is determined by the output_short_name of the output ScheduledDiagnostic. New files are created for each timestep.\n\nFields can be read back using the InputOutput module in ClimaCore.\n\n\n\n\n\nwrite_field!(writer::NetCDFWriter, field::Fields.Field, diagnostic, u, p, t)\n\nSave the resampled field produced by diagnostic as directed by the writer.\n\nOnly the root process does something here.\n\nNote: It assumes that the field is already resampled.\n\nThe target file is determined by output_short_name(diagnostic). If the target file already exists, append to it. If not, create a new file. If the file does not contain dimensions, they are added the first time something is written.\n\nAttributes are appended to the dataset:\n\nshort_name\nlong_name\nunits\ncomments\nstart_date\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.close","page":"APIs","title":"Base.close","text":"close(writer::HDF5Writer)\n\nClose all the files open in writer. (Currently no-op.)\n\n\n\n\n\nclose(writer::NetCDFWriter)\n\nClose all the open files in writer.\n\n\n\n\n\n","category":"function"},{"location":"user_guide/#user_guide_header","page":"User guide","title":"What do I have to do to use ClimaDiagnostics?","text":"","category":"section"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"In this page, we describe the low level interface that ClimaDiagnostics offers to work with diagnostics. Most packages implement addition interface to streamline computing and outputting diagnostics, so you should first refer to the manual of your package of interest. Come back here if you want to go beyond what the package developers offer and unlock the full power of ClimaDiagnostics.","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"There are two fundamental objects in ClimaDiagnostics: the DiagnosticVariable, and the ScheduledDiagnostic.","category":"page"},{"location":"user_guide/#DiagnosticVariables","page":"User guide","title":"DiagnosticVariables","text":"","category":"section"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"A DiagnosticVariable is a recipe on how to compute something alongside with some metadata.","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"For example, a DiagnosticVariable might be the air temperature. In pseudocode, some of the information we might want to include attach to the air temperature are:","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"short_name: \"ta\"\nlong_name: \"Air Temperature\"\nunits: \"K\"\nhow_to_compute: state.ta\n...","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"The definition of what a DiagnosticVariable is. Conceptually, a DiagnosticVariable is a variable we know how to compute from the state. We attach more information to it for documentation and to reference to it with its short name. DiagnosticVariables can exist irrespective of the existence of an actual simulation that is being run. Science packages are encourage to define their set of pre-made DiagnosticVariables, for example, ClimaAtmos comes with several diagnostics already defined (in the ALL_DIAGNOSTICS dictionary).","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"Let us see how we would define a DiagnosticVariable","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"import ClimaDiagnostics: DiagnosticVariable\n\nfunction compute_ta!(out, state, cache, time)\n    if isnothing(out)\n        return copy(state.ta)\n    else\n        out .= state.ta\n    end\nend\n\nvar = DiagnosticVariable(;\n    short_name = \"ta\",\n    long_name = \"Air Temperature\",\n    standard_name = \"air_temperature\",\n    comments = \"Measured assuming that the air is in quantum equilibrium with the metaverse\",\n    units = \"K\",\n    compute! = compute_ta!\n)","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"compute_ta! is the key function here. It determines how the variable should be computed from the state, cache, and time of the simulation. Typically, these are packaged within an integrator object (e.g., state = integrator.u or integrator.Y).","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"compute_ta! takes another argument, out. out is an area of memory managed by ClimaDiagnostics that is used to reduce the number of allocations needed when working with diagnostics. The first time the diagnostic is called, an area of memory is allocated and filled with the value (this is when out is nothing). All the subsequent times, the same space is overwritten, leading to much better performance. You should follow this pattern in all your diagnostics.","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"Note, in the future, we hope to improve this rather clumsy way to write diagnostics. Hopefully, at some you will just have to write something like state.ta and not worry about the out at all.","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"A DiagnosticVariable defines what a variable is and how to compute it, but does not specify when to compute/output it. For that, we need ScheduledDiagnostics.","category":"page"},{"location":"user_guide/#ScheduledDiagnostics","page":"User guide","title":"ScheduledDiagnostics","text":"","category":"section"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"A ScheduledDiagnostic is a DiagnosticVariable with attached a schedule on when it should be computed and output, as well as what reductions should be performed and how the file should be written.","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"Continuing our example on ta. Suppose we want to compute the average of the air temperature over a month. We would package this in a ScheduledDiagnostic that knows that we want to compute the air temperature, and we want it averaged over a month.","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"Let us examine what is in a ScheduledDiagnostic in more details:","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"variable, the DiagnosticVariable we want to compute.\ntwo schedule functions that determine when the variable should be computed and output (compute_schedule_func and output_schedule_func). We have two separate entries one for compute and one for output because we might want to control them separately. For instance, we might want to take the average of something every 10 steps, and output it the average every 100 iterations. schedule functions are powerful, so there is an entire section dedicated to them below. compute_schedule_func and output_schedule_func are likely going to the same unless there are temporal reductions.\nan output_writer, an object that knows how what to do with the output. Examples of writers might be the DictWriter, which saves the output to a dictionary, or the NetCDFWriter, which saves the output to NetCDF files. A more complete description of the available writers is in Saving the diagnostics page.\noutput_short_name and output_long_name, two strings that specify the names that should be used for the output. Typically, output_short_name is used for file/key names, output_long_name is used for descriptive attributes. If none is provided, one is automatically generated by the output_short_name and output_long_name functions.\nreduction_time_func, a function that implements a temporal reduction. Discussed later. This is what you need to implement operations like arithmetic averages. A pre_output_hook! function can also be passed to do some basic normalization operations.","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"Note that we can have multiple ScheduledDiagnostics for the same DiagnosticVariable (e.g., daily and monthly average temperatures).","category":"page"},{"location":"user_guide/#Schedules","page":"User guide","title":"Schedules","text":"","category":"section"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"ScheduledDiagnostics contain two arguments compute_schedule_func and output_schedule_func which dictate when the variable should be computed and when it should be output. These objects have to be functions that take a single argument (the integrator) and return a boolean value.","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"For example, if we want to call a callback every even step, we could pass","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"function compute_every_even(integrator)\n    return mod(integrator.step, 2) == 0\nend","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"Schedules can be arbitrary. For example, we might want to compute something if the value of the variable var is greater than 100 anywhere. The relevant schedule for this would be","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"function compute_if_larger_than100(integrator)\n    return maximum(integrator.u.var) > 100\nend","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"Strictly speaking, schedules do not have to functions, but callable objects. For example, the compute_every_even schedule we defined earlier could be written for a more general divisor","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"struct EveryDivisor\n    divisor::Int\nend\n\nfunction (schedule::EveryDivisor)(integrator)\n    return mod(integrator.step, schedule.divisor) == 0\nend\n\ncompute_every_even = EveryDivisor(2)","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"This gives schedules great flexibility because it allows them to contain a state that can be changed.","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"ClimaDiagnostics define an AbstractSchedule type to implement generic schedules following the pattern just illustrated. One of the main roles of AbstractSchedules is to have meaningful names that can be used in files/datasets/error messages, and so on. For this reason, Schedules in ClimaDiagnostics define methods for short_name and long_name.","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"If you define your own schedule, you are encouraged to define those methods too.","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"Let us see a complete example of a new schedule that returns true when a variable is greater than a threshold.","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"import ClimaDiagnostics\n\nstruct ExceedThresholdSchedule <: ClimaDiagnostics.AbstractSchedule\n    var::Symbol\n    threshold::Float64\nend\n\nfunction (schedule::ExceedThresholdSchedule)(integrator)\n    return maximum(getproperty(integrator.u, schedule.var)) > schedule.threshold\nend\n\nfunction ClimaDiagnostics.Callback.short_name(schedule::ExceedThresholdSchedule)\n    return \"$(schedule.var)_more_than_$(schedule.threshold)\"\nend\n\nfunction ClimaDiagnostics.Callback.long_name(schedule::ExceedThresholdSchedule)\n    return \"when max($(schedule.var)) >= $(schedule.threshold)\"\nend","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"Names are not too important, but they should be meaningful to you.","category":"page"},{"location":"user_guide/#Temporal-reductions","page":"User guide","title":"Temporal reductions","text":"","category":"section"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"It is often useful to compute aggregate data (e.g., monthly averages). In ClimaDiagnostics, this is implemented with through temporal reductions.","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"Let us assume we want to compute the maximum of the air temperature within a month. To achieve this, we simply pass the max function to reduction_time_func and choose our window in the output_schedule_func.","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"The only temporal reductions allowed are ones defined by associative operations, that is, functions f so that f(a, b, c, d, ...) = f(a, f(b, f(c, f(d, ...)))) (such as the sum). The reason for this restriction comes from the fact that we do not store all the intermediate values (which would lead to large consumption of memory). Instead, we accumulate intermediate results. So, the only statistics that can be computed are the ones that can be computed by adding one element at the time.","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"More specifically, when a ScheduledDiagnostic is created with a reduction_time_func, ClimaDiagnostics allocates an extra area of space accumulated for the accumulated value. Every time compute_schedule_func is true, the DiagnosticVariable is computed and saved to out. Then, accumulated is updated with the return value of reduction_time_func(accumulated, out). When output_schedule_func is true, the accumulated value is written with the writer and the state reset to the neutral state.","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"To allow for greater flexibility, ClimaDiagnostics also provides the option to evaluate a function before the output is saved. This is the pre_output_hook! function that can be provided when defining a ScheduledDiagnostic. The signature for pre_output_hook! has to be pre_output_hook!(accumulated_value, counter), where counter is the number of times the diagnostic was called. Given this, the arithmetic average is obtained with a + time reduction and a pre_output_hook! = (acc, counter) -> acc .= acc ./ counter. Given that averages are very common operations, ClimaDiagnostics directly provides the pre_output_hook. So, to define an average, you can directly import and use ClimaDiagnostics.average_pre_output_hook!.","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"The following is a sketch of what happens at the end of each step for each ScheduledDiagnostic:","category":"page"},{"location":"user_guide/","page":"User guide","title":"User guide","text":"if compute_schedule_func is true:\n    out = compute!\n    if reduction_time_func is not nothing:\n        accumulated_value = reduction_time_func(accumulated_value, out)\n        counter += 1\nif output_schedule_func is true:\n    pre_output_hook(accumulated_value, counter)\n    interpolate(accumulated_value)\n    dump(accumulated_value)\n    reset(accumulated_value)\n    reset(counter)","category":"page"},{"location":"developer_guide/#I-am-a-developer,-how-do-I-add-ClimaDiagnostics.jl-to-my-package?","page":"How to add ClimaDiagnostics to a package","title":"I am a developer, how do I add ClimaDiagnostics.jl to my package?","text":"","category":"section"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"This page provides additional documentation on abstractions to use ClimaDiagnostics. Before reading this page, make sure you are familiar with the terminology. You know to know what a DiagnosticVariable and a ScheduledDiagnostic are.","category":"page"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"There are three components needed to add support for ClimaDiagnostics.jl in your package.","category":"page"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"A way to convert users' intentions to a list of ScheduledDiagnostic\nA call to IntegratorWithDiagnostics","category":"page"},{"location":"developer_guide/#Step-2","page":"How to add ClimaDiagnostics to a package","title":"Step 2","text":"","category":"section"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"Let us assume that scheduled_diagnostics is the list of ScheduledDiagnostics obtained from step 1. (more on this later), and integrator a SciML integrator.","category":"page"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"All we need to do to add diagnostics is","category":"page"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"import ClimaDiagnostics: IntegratorWithDiagnostics\n\nintegrator = IntegratorWithDiagnostics(integrator, scheduled_diagnostics)","category":"page"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"Creating an IntegratorWithDiagnostics results in calling all the diagnostics once. Therefore, the compile and runtime of this function can be significant if you have a large number of diagnostics.","category":"page"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"You can learn about what is happening under the hook in the Internals page.","category":"page"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"This is pretty much all that you need to know about step 2.","category":"page"},{"location":"developer_guide/#Step-1","page":"How to add ClimaDiagnostics to a package","title":"Step 1","text":"","category":"section"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"Step 1 in the recipe to bring ClimaDiagnostics to your package strongly depends on you.","category":"page"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"In this section, I will present a tower of interfaces that you can put in place to make it more convenient for your users. Keep in mind that each layer trades more convenience for less flexibility. So, as you set up your interfaces, I recommend you keep them exposed so that your users can access lower-level functions if they need to.","category":"page"},{"location":"developer_guide/#Level-0:-do-nothing","page":"How to add ClimaDiagnostics to a package","title":"Level 0: do nothing","text":"","category":"section"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"At the zero-th level, you let your users work directly with ClimaDiagnostics. This means that they will have to define their own DiagnosticVariables and ScheduledDiagnostics. This also requires that your simulation is executed as a julia script.","category":"page"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"It is a good idea for your users to be aware of this possibility because it brings enormous power. ScheduledDiagnostics can be triggered on arbitrary conditions, and your users could be creative with that. For example, users might want to compute and output a variable var1 when they find that the maximum of variable var2 is greater than a threshold (e.g., for debugging).","category":"page"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"Let us see the simplest example to accomplish this","category":"page"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"import ClimaDiagnostics: DiagnosticVariable, ScheduledDiagnostic\nimport ClimaDiagnostics.Writers: DictWriter\n\nmyvar = DiagnosticVariable(; compute! = (out, u, p, t) -> u.var1)\n\nmyschedule = (integrator) -> maximum(integrator.u.var2) > 10.0\n\ndiag = ScheduledDiagnostic(variable = myvar,\n                           compute_schedule_func = myschedule,\n                           output_schedule_func = myschedule,\n                           output_writer = DictWriter())","category":"page"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"Now we can go to step 2 and 3 in the previous list and pass [diag] to the DiagnosticsHandler.","category":"page"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"Point your users to the documentation of this package for them to learn how to use it in its full power.","category":"page"},{"location":"developer_guide/#Level-1:-provide-a-database-of-DiagnosticVariables","page":"How to add ClimaDiagnostics to a package","title":"Level 1: provide a database of DiagnosticVariables","text":"","category":"section"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"As a package developer, you know that there is a large collection of variables that several users will be interested in. For example, if you are running an atmospheric simulation, your users will want to be able to look at the air temperature. For this reason, it is a very good (and user-friendly) idea to provide a collection of DiagnosticVariables ready to be used. In this section, I sketch how you could go about and implement this.","category":"page"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"Your DiagnosticVariables database can be represented as a dictionary ALL_DIAGNOSTICS indexed over the short name of the variable. Then, you could provide adders and accessors.","category":"page"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"This might look like the following:","category":"page"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"module Diagnostics\nimport ClimaDiagnostics: DiagnosticVariable\n\nconst ALL_DIAGNOSTICS = Dict{String, DiagnosticVariable}()\n\n\"\"\"\n\n    add_diagnostic_variable!(; short_name,\n                               long_name,\n                               standard_name,\n                               units,\n                               description,\n                               compute!)\n\n\nAdd a new variable to the `ALL_DIAGNOSTICS` dictionary (this function mutates the state of\n`ALL_DIAGNOSTICS`).\n\nIf possible, please follow the naming scheme outline in\nhttps://airtable.com/appYNLuWqAgzLbhSq/shrKcLEdssxb8Yvcp/tblL7dJkC3vl5zQLb\n\nKeyword arguments\n=================\n\n- `short_name`: Name used to identify the variable in the output files and in the file\n                names. Short but descriptive. Diagnostics are identified by the short name.\n\n- `long_name`: Name used to identify the variable in the output files.\n\n- `standard_name`: Standard name, as in\n                   http://cfconventions.org/Data/cf-standard-names/71/build/cf-standard-name-table.html\n\n- `units`: Physical units of the variable.\n\n- `comments`: More verbose explanation of what the variable is, or comments related to how\n              it is defined or computed.\n\n- `compute!`: Function that compute the diagnostic variable from the state. It has to take\n              two arguments: the `integrator`, and a pre-allocated area of memory where to\n              write the result of the computation. It the no pre-allocated area is\n              available, a new one will be allocated. To avoid extra allocations, this\n              function should perform the calculation in-place (i.e., using `.=`).\n\n\"\"\"\nfunction add_diagnostic_variable!(;\n    short_name,\n    long_name,\n    standard_name = \"\",\n    units,\n    comments = \"\",\n    compute!,\n)\n    haskey(ALL_DIAGNOSTICS, short_name) && @warn(\n        \"overwriting diagnostic `$short_name` entry containing fields\\n\" *\n        \"$(map(\n            field -> \"$(getfield(ALL_DIAGNOSTICS[short_name], field))\",\n            # We cannot really compare functions...\n            filter(field -> field != :compute!, fieldnames(DiagnosticVariable)),\n        ))\"\n    )\n\n    ALL_DIAGNOSTICS[short_name] = DiagnosticVariable(;\n        short_name,\n        long_name,\n        standard_name,\n        units,\n        comments,\n        compute!,\n    )\n\n\"\"\"\n    get_diagnostic_variable!(short_name)\n\nReturn a `DiagnosticVariable` from its `short_name`, if it exists.\n\"\"\"\nfunction get_diagnostic_variable(short_name)\n    haskey(ALL_DIAGNOSTICS, short_name) ||\n        error(\"diagnostic $short_name does not exist\")\n\n    return ALL_DIAGNOSTICS[short_name]\nend\n\nend","category":"page"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"Of course, you should have the fields and comments that are relevant to your package.","category":"page"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"Next, as a developer, you will use add_diagnostic_variable! to populate your database. You can also expose your users to this function so that they can extend their personal database in their simulations.","category":"page"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"A simple example of a new variable might look like","category":"page"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"###\n# Density (3d)\n###\nadd_diagnostic_variable!(\n    short_name = \"rhoa\",\n    long_name = \"Air Density\",\n    standard_name = \"air_density\",\n    units = \"kg m^-3\",\n    compute! = (out, state, cache, time) -> begin\n        if isnothing(out)\n            return copy(state.c.ρ)\n        else\n            out .= state.c.ρ\n        end\n    end,\n)","category":"page"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"It is a good idea to put safeguards in place to ensure that your users will not be allowed to call diagnostics that do not make sense for the simulation they are running. If your package has a notion of Model that is stored in p, you can dispatch over that and return an error. A simple example might be","category":"page"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"###\n# Specific Humidity\n###\ncompute_hus!(out, state, cache, time) =\n    compute_hus!(out, state, cache, time, cache.atmos.moisture_model)\n\ncompute_hus!(out, state, cache, time) =\n    compute_hus!(out, state, cache, time, cache.model.moisture_model)\ncompute_hus!(_, _, _, _, model::T) where {T} =\n    error(\"Cannot compute hus with $model\")\n\nfunction compute_hus!(\n    out,\n    state,\n    cache,\n    time,\n    moisture_model::T,\n) where {T <: Union{EquilMoistModel, NonEquilMoistModel}}\n    if isnothing(out)\n        return state.c.ρq_tot ./ state.c.ρ\n    else\n        out .= state.c.ρq_tot ./ state.c.ρ\n    end\nend\n\nadd_diagnostic_variable!(\n    short_name = \"hus\",\n    long_name = \"Specific Humidity\",\n    standard_name = \"specific_humidity\",\n    units = \"kg kg^-1\",\n    comments = \"Mass of all water phases per mass of air\",\n    compute! = compute_hus!,\n)","category":"page"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"This relies on dispatching over moisture_model. If model is not in Union{EquilMoistModel, NonEquilMoistModel}, the code returns an informative error.","category":"page"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"If you provide a database, users can create their ScheduledDiagnostics directly from the DiagnosticVariables you provided.","category":"page"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"For instance to output the specific humidity every 5 iterations:","category":"page"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"import ClimaDiagnostics: ScheduledDiagnostic\nimport ClimaDiagnostics.Callbacks: DivisorSchedule\nimport ClimaDiagnostics.Writers: DictWriter\n\ndiag = ScheduledDiagnostic(variable = get_diagnostic_variable!(\"hus\"),\n                           output_schedule_func = DivisorSchedule(5),\n                           output_writer = DictWriter())","category":"page"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"Alongside with providing the DiagnosticVariables, you can also provide convenience functions for standard operations.","category":"page"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"For example, you could provide","category":"page"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"using ClimaDiagnostics.Callbacks: EveryStepSchedule, EveryDtSchedule\n\nfunction monthly_average(short_name; output_writer, t_start)\n    period = 30 * 24 * 60 * 60 * one(t_start)\n    return ScheduledDiagnostic(\n            variable = get_diagnostic_variable(short_name),\n            compute_schedule_func = EveryStepSchedule(),\n            output_schedule_func = EveryDtSchedule(period; t_start),\n            reduction_time_func = (+),\n            output_writer = output_writer,\n            pre_output_hook! = average_pre_output_hook!,\n        )\nend","category":"page"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"Allowing users to just call monthly_average(\"hus\", writer, t_start).","category":"page"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"Note: ClimaDiagnostics will probably provided these schedules natively at some point in the future.","category":"page"},{"location":"developer_guide/#Level-2:-Provide-higher-level-interfaces-(e.g.,-YAML)","page":"How to add ClimaDiagnostics to a package","title":"Level 2: Provide higher-level interfaces (e.g., YAML)","text":"","category":"section"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"Finally, you can set in place that parses user input (e.g., from command line or text files) into ScheduledDiagnostics using the short names in your database. Of course, this interface will be limited to what you expose.","category":"page"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"For example, a simple parser that allow users to specify ScheduledDiagnostics by their short name, accumulation/output period, and their writer might look like the following:","category":"page"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"import ClimaDiagnostics: average_pre_output_hook!, HDF5Writer, NetCDFWriter, ScheduledDiagnostic\n\nfunction parse_yaml(parsed_args, target_space)\n    # We either get the diagnostics section in the YAML file, or we return an empty list\n    # (which will result in an empty list being created by the map below)\n    yaml_diagnostics = get(parsed_args, \"diagnostics\", [])\n\n    # ALLOWED_REDUCTIONS is the collection of reductions we support. The keys are the\n    # strings that have to be provided in the YAML file. The values are tuples with the\n    # function that has to be passed to reduction_time_func and the one that has to passed\n    # to pre_output_hook!\n\n    # We make \"nothing\" a string so that we can accept also the word \"nothing\", in addition\n    # to the absence of the value\n    #\n    # NOTE: Everything has to be lowercase in ALLOWED_REDUCTIONS (so that we can match\n    # \"max\" and \"Max\")\n    ALLOWED_REDUCTIONS = Dict(\n        \"nothing\" => (nothing, nothing), # nothing is: just dump the variable\n        \"max\" => (max, nothing),\n        \"min\" => (min, nothing),\n        \"average\" => ((+), average_pre_output_hook!),\n    )\n\n    output_dir = parsed_args.output_dir\n\n    hdf5_writer = HDF5Writer(output_dir)\n    netcdf_writer = CAD.NetCDFWriter(\n        target_space,\n        output_dir,\n    )\n    writers = (hdf5_writer, netcdf_writer)\n\n    # The default writer is HDF5\n    ALLOWED_WRITERS = Dict(\n        \"nothing\" => netcdf_writer,\n        \"h5\" => hdf5_writer,\n        \"hdf5\" => hdf5_writer,\n        \"nc\" => netcdf_writer,\n        \"netcdf\" => netcdf_writer,\n    )\n\n    diagnostics_ragged = map(yaml_diagnostics) do yaml_diag\n        short_names = yaml_diag[\"short_name\"]\n        output_name = get(yaml_diag, \"output_name\", nothing)\n\n        map(short_names) do short_name\n            # Return \"nothing\" if \"reduction_time\" is not in the YAML block\n            #\n            # We also normalize everything to lowercase, so that can accept \"max\" but\n            # also \"Max\"\n            reduction_time_yaml =\n                lowercase(get(yaml_diag, \"reduction_time\", \"nothing\"))\n\n            if !haskey(ALLOWED_REDUCTIONS, reduction_time_yaml)\n                error(\"reduction $reduction_time_yaml not implemented\")\n            else\n                reduction_time_func, pre_output_hook! =\n                    ALLOWED_REDUCTIONS[reduction_time_yaml]\n            end\n\n            writer_ext = lowercase(get(yaml_diag, \"writer\", \"nothing\"))\n\n            if !haskey(ALLOWED_WRITERS, writer_ext)\n                error(\"writer $writer_ext not implemented\")\n            else\n                writer = ALLOWED_WRITERS[writer_ext]\n            end\n\n            haskey(yaml_diag, \"period\") ||\n                error(\"period keyword required for diagnostics\")\n\n            period_seconds = FT(time_to_seconds(yaml_diag[\"period\"]))\n\n            if isnothing(reduction_time_func)\n                compute_every = CAD.EveryDtSchedule(period_seconds; t_start)\n            else\n                compute_every = CAD.EveryStepSchedule()\n            end\n\n            ScheduledDiagnostic(\n                variable = get_diagnostic_variable(short_name),\n                output_schedule_func = CAD.EveryDtSchedule(period_seconds; t_start),\n                compute_schedule_func = compute_every,\n                reduction_time_func = reduction_time_func,\n                pre_output_hook! = pre_output_hook!,\n                output_writer = writer,\n            )\n        end\n    end\n\n    # Flatten the array of arrays of diagnostics\n    diagnostics = vcat(diagnostics_ragged...)\nend","category":"page"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"This will be controlled by YAML blocks like","category":"page"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"diagnostics:\n    - short_name: [\"ta\", \"va\"]\n      period: 60s\n      writer: nc\n    - short_name: [\"ua\"]\n      period: 1200s\n      reduction_time: \"average\"","category":"page"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"It is typically a good idea to add the default diagnostics to the set of YAML-specified ones.","category":"page"},{"location":"developer_guide/#API","page":"How to add ClimaDiagnostics to a package","title":"API","text":"","category":"section"},{"location":"developer_guide/","page":"How to add ClimaDiagnostics to a package","title":"How to add ClimaDiagnostics to a package","text":"ClimaDiagnostics.IntegratorWithDiagnostics","category":"page"},{"location":"#ClimaDiagnostics.jl","page":"Overview","title":"ClimaDiagnostics.jl","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"ClimaDiagnostics.jl is a module that adds diagnostics to your CliMA simulations. Diagnostics are variables that are computed from your state when specific conditions are met (typically at set intervals of time) throughout the run and typically saved to disk.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"ClimaDiagnostics.jl provides the infrastructure to schedule, compute, reduce, and output such variables.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"If you are a user of a package that is already using ClimaDiagnostics.jl, you can jump to the User guide page.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"If you are a developer interested in adding support for ClimaDiagnostics.jl in your package or learning about the internal design of this package, please read the Developer guide page.","category":"page"},{"location":"#Features","page":"Overview","title":"Features","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"Define diagnostics as function of the integrator state and the cache;\nAccumulate diagnostics over period of times with associative binary temporal reductions (eg, averages);\nAllow users to define arbitrary new diagnostics;\nTrigger diagnostics on arbitrary conditions;\nSave output to HDF5 or NetCDF files, or a dictionary in memory;","category":"page"},{"location":"internals/#internals_header","page":"Internals","title":"Some notes about the internals of ClimaDiagnostics","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"There are multiple moving parts to this package. In this page, we provide some notes about the internal design. This page also aims at clarifying the whys, i.e., explaining why things are the way they are. Learning about that might help you extend this package further.","category":"page"},{"location":"internals/#Schedules","page":"Internals","title":"Schedules","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"Diagnostics are computed with a callback that is called at the end of each step. The centerpiece of is the orchestrate_diagnostics function, a master callback that is unconditionally executed at the end of each step. orchestrate_diagnostics loops over each registered diagnostic, computing and output those for which their trigger condition is met. Conditions are specified with schedule functions, function that take the integrator as single argument and return a boolean value that determines whether the callback should be executed or note. Most often, schedules_func are not simple functions, but callable objects (subtypes of AbstractSchedule). There are two reasons for this:","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Most realistic schedules need to hold additional data (e.g., the last time the function was called)\nWe want to attach names to use in the output","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Most of the details regarding schedules are described in the user guide. An internal detail that is not there is related to names. We define a method for show for AbstractSchedules. This method calls the short_name function.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Base.show(io::IO, schedule::AbstractSchedule) =  print(io, short_name(schedule))","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"This allows us to set names of ScheduledDiagnostics with \"$schedule_func\" in both the case schedule_func is a normal function, or an AbstractSchedule.","category":"page"},{"location":"internals/#Accumulation","page":"Internals","title":"Accumulation","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"Several diagnostics require performing reductions, such as taking the maximum or the average. Since it is not feasible to store all the lists of all the intermediate values, we aggregate the results in specific storage areas (e.g., we take max(max(max(max(t1, t2), t3), t4), t5) instead of max(t1, t2, t3, t4, t5) In this, it is convenient to preallocate the space where we want to accumulate the intermediate.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Accumulation is accomplished by the accumulate! function. All this function does is applying the binary reduction_time_func to the previous accumulated value and the newly computed one and store the output to the accumulator.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"After an accumulated variable is output, the accumulator is reset to its natural state. This is achieved with the reset_accumulator! function. However, we have to fill the space with something that does not affect the reduction. This, by definition, is the identity of the operation. The identity of the operation + is 0 because x + 0 = x for every x.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"We have to know the identity for every operation we want to support. Of course, users are welcome to define their own by adding new methods to identityofreduction.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"For instance, to define the identity of the reduction -, one would write","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"function ClimaDiagnostics.Diagnostics.identity_of_reduction(::typeof(-))\n    return 0\nend","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"(Or add this to the reduction_identities.jl file.)","category":"page"},{"location":"internals/#On-the-design-of-the-DiagnosticsHandler","page":"Internals","title":"On the design of the DiagnosticsHandler","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"There are two possible choices for accumulation of variables: each scheduled diagnostic can carry its accumulator and counters, or all the accumulators and counters are managed by a single central handler. ClimaDiagnostics implements this second approach. The author of this package has not decided whether this is a good idea or not. On one side, this allows us to have a concretely typed and well defined DiagnosticsHandler struct. On the other side, it forces us to initialize all the diagnostics at the very beginning of the simulation (this can also be a positive side, because it allows us to compile all the diagnostics at once). It might be worth exploring the alternative design where the ScheduledDiagnostics get their storage space the first time they are called.","category":"page"},{"location":"internals/","page":"Internals","title":"Internals","text":"Given this restriction, the main entry point for ClimaDiagnostics is the IntegratorWithDiagnostics function. This function is a little dissatisfying because it creates a new integrator obtained by copying all the fields of the old one and adding the diagnostics (with Accessors).","category":"page"},{"location":"internals/#Orchestrate-diagnostics","page":"Internals","title":"Orchestrate diagnostics","text":"","category":"section"},{"location":"internals/","page":"Internals","title":"Internals","text":"One of the design goals for orchestrate_diagnostics is to keep all the broadcasted expression in the same function scope. This opens a path to optimize the number of GPU kernel launches. ","category":"page"}]
}
