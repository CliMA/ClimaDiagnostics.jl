<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>User guide · ClimaDiagnostics.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="ClimaDiagnostics.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">ClimaDiagnostics.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Overview</a></li><li class="is-active"><a class="tocitem" href>User guide</a></li><li><a class="tocitem" href="../writers/">Saving output</a></li><li><a class="tocitem" href="../developer_guide/">How to add ClimaDiagnostics to a package</a></li><li><a class="tocitem" href="../internals/">Internals</a></li><li><a class="tocitem" href="../api/">APIs</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>User guide</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>User guide</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/CliMA/ClimaDiagnostics.jl/blob/main/docs/src/user_guide.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="user_guide_header"><a class="docs-heading-anchor" href="#user_guide_header">What do I have to do to use <code>ClimaDiagnostics</code>?</a><a id="user_guide_header-1"></a><a class="docs-heading-anchor-permalink" href="#user_guide_header" title="Permalink"></a></h1><p>In this page, we describe the low level interface that <code>ClimaDiagnostics</code> offers to work with diagnostics. Most packages implement addition interface to streamline computing and outputting diagnostics, so you should first refer to the manual of your package of interest. Come back here if you want to go beyond what the package developers offer and unlock the full power of <code>ClimaDiagnostics</code>.</p><p>There are two fundamental objects in <code>ClimaDiagnostics</code>: the <code>DiagnosticVariable</code>, and the <code>ScheduledDiagnostic</code>.</p><h4 id="DiagnosticVariables"><a class="docs-heading-anchor" href="#DiagnosticVariables"><code>DiagnosticVariable</code>s</a><a id="DiagnosticVariables-1"></a><a class="docs-heading-anchor-permalink" href="#DiagnosticVariables" title="Permalink"></a></h4><p>A <code>DiagnosticVariable</code> is a recipe on how to compute something alongside with some metadata.</p><p>For example, a <code>DiagnosticVariable</code> might be the air temperature. In pseudocode, some of the information we might want to include attach to the air temperature are:</p><pre><code class="language-yaml hljs">short_name: &quot;ta&quot;
long_name: &quot;Air Temperature&quot;
units: &quot;K&quot;
how_to_compute: state.ta
...</code></pre><p>Conceptually, a <code>DiagnosticVariable</code> is a variable we know how to compute from the state. We attach more information to it for documentation and to reference to it with its short name. <code>DiagnosticVariables</code> can exist irrespective of the existence of an actual simulation that is being run. Science packages are encouraged to define their set of pre-made <code>DiagnosticVariables</code>, for example, <code>ClimaAtmos</code> comes with several diagnostics already defined (in the <code>ALL_DIAGNOSTICS</code> dictionary).</p><p>Let us see how we would define a <code>DiagnosticVariable</code></p><pre><code class="language-julia hljs">import ClimaDiagnostics: DiagnosticVariable

function compute_ta!(out, state, cache, time)
    if isnothing(out)
        return state.ta
    else
        out .= state.ta
    end
end

var = DiagnosticVariable(;
    short_name = &quot;ta&quot;,
    long_name = &quot;Air Temperature&quot;,
    standard_name = &quot;air_temperature&quot;,
    comments = &quot;Measured assuming that the air is in quantum equilibrium with the metaverse&quot;,
    units = &quot;K&quot;,
    compute! = compute_ta!
)</code></pre><p><code>compute_ta!</code> is the key function here. It determines how the variable should be computed from the <code>state</code>, <code>cache</code>, and <code>time</code> of the simulation. Typically, these are packaged within an <code>integrator</code> object (e.g., <code>state = integrator.u</code> or <code>integrator.Y</code>).</p><p><code>compute_ta!</code> takes another argument, <code>out</code>. <code>out</code> is an area of memory managed by <code>ClimaDiagnostics</code> that is used to reduce the number of allocations needed when working with diagnostics. The first time the diagnostic is called, an area of memory is allocated and filled with the value (this is when <code>out</code> is <code>nothing</code>). All the subsequent times, the same space is overwritten, leading to much better performance. You should follow this pattern in all your diagnostics.</p><blockquote><p>Note, in the future, we hope to improve this rather clumsy way to write diagnostics. Hopefully, at some point you will just have to write something like <code>state.ta</code> and not worry about the <code>out</code> at all.</p></blockquote><p>A <code>DiagnosticVariable</code> defines what a variable is and how to compute it, but does not specify when to compute/output it. For that, we need <code>ScheduledDiagnostic</code>s.</p><h4 id="ScheduledDiagnostics"><a class="docs-heading-anchor" href="#ScheduledDiagnostics"><code>ScheduledDiagnostic</code>s</a><a id="ScheduledDiagnostics-1"></a><a class="docs-heading-anchor-permalink" href="#ScheduledDiagnostics" title="Permalink"></a></h4><p>A <code>ScheduledDiagnostic</code> is a <code>DiagnosticVariable</code> with attached a schedule on when it should be computed and output, as well as what reductions should be performed and how the file should be written.</p><p>Continuing our example on <code>ta</code>. Suppose we want to compute the average of the air temperature over a month. We would package this in a <code>ScheduledDiagnostic</code> that knows that we want to compute the air temperature, and we want it averaged over a month.</p><p>Let us examine what is in a <code>ScheduledDiagnostic</code> in more details:</p><ul><li><p><code>variable</code>, the <code>DiagnosticVariable</code> we want to compute.</p></li><li><p>two <code>schedule</code> functions that determine when the variable should be computed and output (<code>compute_schedule_func</code> and <code>output_schedule_func</code>). We have two separate entries one for compute and one for output because we might want to control them separately. For example, we might want to take the average of something every 10 steps, and output it the average every 100 iterations. <code>schedule</code> functions are powerful, so there is an entire section dedicated to them below. <code>compute_schedule_func</code> and <code>output_schedule_func</code> are likely going to be the same unless there are temporal reductions.</p></li><li><p>an <code>output_writer</code>, an object that knows what to do with the output. Examples of writers might be the <code>DictWriter</code>, which saves the output to a dictionary, or the <code>NetCDFWriter</code>, which saves the output to NetCDF files. A more complete description of the available writers is in <a href="../writers/#Saving-the-diagnostics">Saving the diagnostics</a> page.</p></li><li><p><code>output_short_name</code> and <code>output_long_name</code>, two strings that specify the names that should be used for the output. Typically, <code>output_short_name</code> is used for file/key names, <code>output_long_name</code> is used for descriptive attributes. If none is provided, one is automatically generated by the <a href="../api/#ClimaDiagnostics.ScheduledDiagnostics.output_short_name"><code>output_short_name</code></a> and <a href="../api/#ClimaDiagnostics.ScheduledDiagnostics.output_long_name"><code>output_long_name</code></a> functions.</p></li><li><p><code>reduction_time_func</code>, a function that implements a temporal reduction. Discussed later. This is what you need to implement operations like arithmetic averages. A <code>pre_output_hook!</code> function can also be passed to do some basic normalization operations.</p></li></ul><p>Note that we can have multiple <code>ScheduledDiagnostic</code>s for the same <code>DiagnosticVariable</code> (e.g., daily and monthly average temperatures).</p><h5 id="schedules_header"><a class="docs-heading-anchor" href="#schedules_header"><code>Schedules</code></a><a id="schedules_header-1"></a><a class="docs-heading-anchor-permalink" href="#schedules_header" title="Permalink"></a></h5><p><code>ScheduledDiagnostic</code>s contain two arguments <code>compute_schedule_func</code> and <code>output_schedule_func</code> which dictate when the variable should be computed and when it should be output. These objects have to be functions that take a single argument (the integrator) and return a boolean value.</p><p>For example, if we want to call a callback every even step, we could pass</p><pre><code class="language-julia hljs">function compute_every_even(integrator)
    return mod(integrator.step, 2) == 0
end</code></pre><p>Schedules can be arbitrary. For example, we might want to compute something if the value of the variable <code>var</code> is greater than 100 anywhere. The relevant schedule for this would be</p><pre><code class="language-julia hljs">function compute_if_larger_than100(integrator)
    return maximum(integrator.u.var) &gt; 100
end</code></pre><p>Strictly speaking, schedules do not have to be functions, but callable objects. For example, the <code>compute_every_even</code> schedule we defined earlier could be written for a more general divisor</p><pre><code class="language-julia hljs">struct EveryDivisor
    divisor::Int
end

function (schedule::EveryDivisor)(integrator)
    return mod(integrator.step, schedule.divisor) == 0
end

compute_every_even = EveryDivisor(2)</code></pre><p>This gives schedules great flexibility because it allows them to contain a state that can be changed.</p><p><code>ClimaDiagnostics</code> define an <code>AbstractSchedule</code> type to implement generic schedules following the pattern just illustrated. One of the main roles of <code>AbstractSchedule</code>s is to have meaningful names that can be used in files/datasets/error messages, and so on. For this reason, <code>Schedule</code>s in <code>ClimaDiagnostics</code> define methods for <code>short_name</code> and <code>long_name</code>.</p><p>If you define your own schedule, you are encouraged to define those methods too.</p><p>Let us see a complete example of a new schedule that returns true when a variable is greater than a threshold.</p><pre><code class="language-julia hljs">import ClimaDiagnostics

struct ExceedThresholdSchedule &lt;: ClimaDiagnostics.AbstractSchedule
    var::Symbol
    threshold::Float64
end

function (schedule::ExceedThresholdSchedule)(integrator)
    return maximum(getproperty(integrator.u, schedule.var)) &gt; schedule.threshold
end

function ClimaDiagnostics.Callback.short_name(schedule::ExceedThresholdSchedule)
    return &quot;$(schedule.var)_more_than_$(schedule.threshold)&quot;
end

function ClimaDiagnostics.Callback.long_name(schedule::ExceedThresholdSchedule)
    return &quot;when max($(schedule.var)) &gt;= $(schedule.threshold)&quot;
end</code></pre><p>Names are not too important, but they should be meaningful to you.</p><p><code>ClimaDiagnostics</code> comes with some predefined schedules for common operations, such out every N timesteps, or every calendar period. Refer to the <a href="#schedules_header"><code>Schedules</code></a> section below for more information on what is already implemented.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>Schedule</code>s store some information about the last time they were called, so different <code>Schedule</code>s have to be used and created for different purposes. You can use the <code>deepcopy</code> function to quickly create a new <code>Schedule</code>.</p></div></div><h5 id="Temporal-reductions"><a class="docs-heading-anchor" href="#Temporal-reductions">Temporal reductions</a><a id="Temporal-reductions-1"></a><a class="docs-heading-anchor-permalink" href="#Temporal-reductions" title="Permalink"></a></h5><p>It is often useful to compute aggregate data (e.g., monthly averages). In <code>ClimaDiagnostics</code>, this is implemented with through temporal reductions.</p><p>Let us assume we want to compute the maximum of the air temperature within a month. To achieve this, we simply pass the <code>max</code> function to <code>reduction_time_func</code> and choose our window in the <code>output_schedule_func</code>.</p><p>The only temporal reductions allowed are ones defined by associative operations, that is, functions <code>f</code> so that <code>f(a, b, c, d, ...) = f(a, f(b, f(c, f(d, ...))))</code> (such as the sum). The reason for this restriction comes from the fact that we do not store all the intermediate values (which would lead to large consumption of memory). Instead, we accumulate intermediate results. So, the only statistics that can be computed are the ones that can be computed by adding one element at the time.</p><p>More specifically, when a <code>ScheduledDiagnostic</code> is created with a <code>reduction_time_func</code>, <code>ClimaDiagnostics</code> allocates an extra area of space <code>accumulated</code> for the accumulated value. Every time <code>compute_schedule_func</code> is true, the <code>DiagnosticVariable</code> is computed and saved to <code>out</code>. Then, <code>accumulated</code> is updated with the return value of <code>reduction_time_func(accumulated, out)</code>. When <code>output_schedule_func</code> is true, the accumulated value is written with the <code>writer</code> and the state reset to the neutral state.</p><p>To allow for greater flexibility, <code>ClimaDiagnostics</code> also provides the option to evaluate a function before the output is saved. This is the <code>pre_output_hook!</code> function that can be provided when defining a <code>ScheduledDiagnostic</code>. The signature for <code>pre_output_hook!</code> has to be <code>pre_output_hook!(accumulated_value, counter)</code>, where <code>counter</code> is the number of times the diagnostic was called. Given this, the arithmetic average is obtained with a <code>+</code> time reduction and a <code>pre_output_hook! = (acc, counter) -&gt; acc .= acc ./ counter</code>. Given that averages are very common operations, <code>ClimaDiagnostics</code> directly provides the <code>pre_output_hook</code>. So, to define an average, you can directly import and use <code>ClimaDiagnostics.average_pre_output_hook!</code>.</p><p>The following is a sketch of what happens at the end of each step for each <code>ScheduledDiagnostic</code>:</p><pre><code class="nohighlight hljs">if compute_schedule_func is true:
    out = compute!
    if reduction_time_func is not nothing:
        accumulated_value = reduction_time_func(accumulated_value, out)
        counter += 1
if output_schedule_func is true:
    pre_output_hook(accumulated_value, counter)
    interpolate(accumulated_value)
    dump(accumulated_value)
    reset(accumulated_value)
    reset(counter)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Overview</a><a class="docs-footer-nextpage" href="../writers/">Saving output »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Monday 28 October 2024 18:58">Monday 28 October 2024</span>. Using Julia version 1.11.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
